diff -ruN src_tmp/veripb/optimized/parsing.cpp veripb/veripb/optimized/parsing.cpp
--- src_tmp/veripb/optimized/parsing.cpp	2022-02-24 21:47:27.064164500 +0100
+++ veripb/veripb/optimized/parsing.cpp	2022-02-24 21:45:56.417591800 +0100
@@ -6,6 +6,7 @@
 #include <unordered_map>
 #include <vector>
 #include <cctype>
+#include <climits>
 
 #include "constraints.hpp"
 #include "BigInt.hpp"
@@ -838,6 +839,169 @@
 };
 
 template<typename T>
+class WCNFParser {
+    VariableNameManager& variableNameManager;
+    std::vector<Term<T>> terms;
+    VarDouplicateDetection duplicateDetection;
+
+    std::unique_ptr<Formula<T>> formula;
+
+    int weighted_partial_top; // Max weight of clause, which generates hard clause
+
+public:
+    WCNFParser(VariableNameManager& mngr):
+        variableNameManager(mngr)
+    {}
+
+
+    std::unique_ptr<Formula<T>> parse(std::ifstream& f, const std::string& fileName) {
+        formula = std::make_unique<Formula<T>>();
+        formula->hasObjective = true;
+        WordIter it(fileName);
+
+        bool foundHeader = false;
+        while (WordIter::getline(f, it)) {
+            if (it != WordIter::end && ((*it)[0] != 'c')) {
+                if (!foundHeader) {
+                    parseHeader(it);
+                    foundHeader = true;
+                } else {
+                    auto res = parseConstraint(it);
+                    formula->add(std::move(res));
+                }
+            }
+        }
+
+        if (!foundHeader) {
+            throw ParseError(it, "Expected WCNF header.");
+        }
+
+        return std::move(formula);
+    }
+
+    void parseHeader(WordIter& it) {
+        it.expect("p");
+        ++it;
+        it.expect("wcnf");
+        ++it;
+        formula->claimedNumVar = parseInt(it, "Expected number of variables.");
+        ++it;
+        formula->claimedNumC = parseInt(it, "Expected number of constraints.");
+        ++it;
+
+        if(it != WordIter::end){
+            weighted_partial_top = parseInt(it, "Value for hard clauses");
+        }
+        else{
+            weighted_partial_top = UINT_MAX;
+        }
+        ++it;
+
+        if (it != WordIter::end) {
+            throw ParseError(it, "Expected end of header line.");
+        }
+    }
+
+    std::unique_ptr<Inequality<T>> parseConstraint(WordIter& it) {
+        terms.clear();
+        duplicateDetection.clear();
+
+        char buffer[12];
+        char* bufferEnd = buffer + 12;
+        char* bufferStart;
+
+        bool hasDuplicates = false;
+        
+        int weight = 0;
+
+        while (it != WordIter::end && *it != "0") {
+
+            // If no weight has been parsed yet, this means that the first value will be the weight of the clause. 
+            // Assumption: add a relaxation variable with name "xi" with i a number in the range [nbvar+1, nbvar+nbclauses].
+            if(weight==0){
+                weight = parseInt(it, "Value expected");
+                
+                if(weight < weighted_partial_top){
+                    formula->claimedNumVar++; // Claim another variable as relaxation variable.
+
+                    std::string name = "x"+ std::to_string(formula->claimedNumVar);
+                    string_view relaxVarName(name);
+                    
+                    Lit lit = variableNameManager.getLit(relaxVarName); // getLit also calls getVar, which adds the variable name to the variable name manager if not exists.
+
+                    terms.emplace_back(1, lit);
+                    
+                    formula->objectiveCoeffs.push_back(weight);
+                    formula->objectiveVars.push_back(lit.var());
+                    formula->maxVar = std::max(formula->maxVar, static_cast<size_t>(lit.var()));
+                }
+                ++it;
+                continue;
+            }
+
+            // Same as cnf parser:
+            
+            // parse int to give nice error messages if input is not
+            // an integer, out put is not used because we construct
+            // string to be consistent with arbitrary variable names
+            parseInt(it, "Expected literal.");
+            if (it->size() > 11) {
+                throw ParseError(it, "Literal too large.");
+            }
+            bufferStart = bufferEnd - it->size();
+            std::copy(it->begin(), it->end(), bufferStart);
+            if (bufferStart[0] == '-') {
+                bufferStart -= 1;
+                bufferStart[0] = '~';
+                bufferStart[1] = 'x';
+            } else {
+                bufferStart -= 1;
+                bufferStart[0] = 'x';
+            }
+
+            std::string_view litString(bufferStart, bufferEnd - bufferStart);
+            Lit lit = parseLit(it, variableNameManager, &litString);
+            if (formula) {
+                formula->maxVar = std::max(formula->maxVar, static_cast<size_t>(lit.var()));
+            }
+
+            terms.emplace_back(1, lit);
+
+            if (duplicateDetection.add(lit.var())) {
+                hasDuplicates = true;
+            }
+
+            // Note that douplicate variables will be handled during
+            // construction of the Inequality that is if a literal
+            // appears twice it will get coefficient 2, if a variable
+            // appears with positive as well as negative polarity then
+            // a cancelation will be triggered reducing the degree to
+            // 0 and thereby trivializing the constraint.
+
+            // todo: maybe add warning if douplicate variables occur?
+
+            ++it;
+        }
+        if (*it != "0") {
+            throw ParseError(it, "Expected '0' at end of clause.");
+        }
+        ++it;
+
+        if (it != WordIter::end) {
+            throw ParseError(it, "Expected end line after constraint.");
+        }
+
+        if (hasDuplicates) {
+            return std::make_unique<Inequality<T>>(terms, 1);
+        } else {
+            return std::make_unique<Inequality<T>>(
+                ClauseHandler(terms.size(), terms.size(), terms.begin(), terms.end()));
+        }
+    }
+};
+
+
+template<typename T>
 class CNFParser {
     VariableNameManager& variableNameManager;
     std::vector<Term<T>> terms;
@@ -959,6 +1123,7 @@
 };
 
 
+
 template<typename T>
 std::unique_ptr<Formula<T>> parseOpb(std::string fileName, VariableNameManager& varMgr) {
     std::ifstream f(fileName);
@@ -982,6 +1147,14 @@
     return result;
 }
 
+template<typename T>
+std::unique_ptr<Formula<T>> parseWcnf(std::string fileName, VariableNameManager& varMgr) {
+    std::ifstream f(fileName);
+    WCNFParser<T> parser(varMgr);
+    std::unique_ptr<Formula<T>> result = parser.parse(f, fileName);
+    return result;
+}
+
 int main(int argc, char const *argv[])
 {
 
@@ -1101,6 +1274,7 @@
     // m.def("parseOpbBigInt", &parseOpb<BigInt>, "Parse opb file with arbitrary precision.");
     m.def("parseCnf", &parseCnf<CoefType>, "Parse cnf file with fixed precision.");
     // m.def("parseCnfBigInt", &parseCnf<BigInt>, "Parse cnf file with arbitrary precision.");
+    m.def("parseWcnf", &parseWcnf<CoefType>, "Parse wcnf file with fixed precision.");
 
     m.def("parseConstraintOpb", &parseOpbConstraint<CoefType>, "Parse opb consraint with fixed precision.");
     // m.def("parseConstraintOpbBigInt", &parseOpbConstraint<BigInt>, "Parse opb constraint with arbitrary precision.");
diff -ruN src_tmp/veripb/utils.py veripb/veripb/utils.py
--- src_tmp/veripb/utils.py	2022-02-24 21:47:27.291810300 +0100
+++ veripb/veripb/utils.py	2022-02-24 21:43:57.309323300 +0100
@@ -17,7 +17,7 @@
 from veripb.parser import RuleParser
 from veripb.exceptions import ParseError
 from veripb.optimized.constraints import PropEngine as CppPropEngine
-from veripb.optimized.parsing import parseOpb,parseCnf
+from veripb.optimized.parsing import parseOpb,parseCnf, parseWcnf
 from veripb.constraints import PropEngine,CppIneqFactory
 from time import perf_counter
 
@@ -66,6 +66,7 @@
         return {
             "drat": False,
             "cnf": False,
+            "wcnf": False,
             "arbitraryPrecision": False,
             "enableFreeNames": True,
             "printStats": False
@@ -90,6 +91,12 @@
             help="Process CNF with PB proof.",
             action="store_true", dest=name+".cnf", default=False
         )
+        
+        group.add_argument(
+            '--wcnf',
+            help="Process WCNF with PB proof. ", #TODO: write about assumption on the variable names.
+            action="store_true", dest=name+".wcnf", default=False
+        )
 
         group.add_argument("--arbitraryPrecision",
             action="store_true",
@@ -153,6 +160,8 @@
 
     if miscSettings.drat or miscSettings.cnf:
         parser = parseCnf
+    elif miscSettings.wcnf:
+        parser = parseWcnf
     else:
         parser = parseOpb
 
diff -ruN src_tmp/.vscode/settings.json veripb/.vscode/settings.json
--- src_tmp/.vscode/settings.json	1970-01-01 01:00:00.000000000 +0100
+++ veripb/.vscode/settings.json	2022-02-24 21:43:57.309804800 +0100
@@ -0,0 +1,61 @@
+{
+    "files.associations": {
+        "*.rmd": "markdown",
+        "*.fcg": "Common Lisp",
+        "*.irl": "common lisp",
+        "array": "cpp",
+        "atomic": "cpp",
+        "bit": "cpp",
+        "*.tcc": "cpp",
+        "cctype": "cpp",
+        "chrono": "cpp",
+        "clocale": "cpp",
+        "cmath": "cpp",
+        "cstdarg": "cpp",
+        "cstddef": "cpp",
+        "cstdint": "cpp",
+        "cstdio": "cpp",
+        "cstdlib": "cpp",
+        "cstring": "cpp",
+        "ctime": "cpp",
+        "cwchar": "cpp",
+        "cwctype": "cpp",
+        "deque": "cpp",
+        "list": "cpp",
+        "unordered_map": "cpp",
+        "unordered_set": "cpp",
+        "vector": "cpp",
+        "exception": "cpp",
+        "algorithm": "cpp",
+        "functional": "cpp",
+        "iterator": "cpp",
+        "memory": "cpp",
+        "memory_resource": "cpp",
+        "numeric": "cpp",
+        "optional": "cpp",
+        "random": "cpp",
+        "ratio": "cpp",
+        "string": "cpp",
+        "string_view": "cpp",
+        "system_error": "cpp",
+        "tuple": "cpp",
+        "type_traits": "cpp",
+        "utility": "cpp",
+        "fstream": "cpp",
+        "initializer_list": "cpp",
+        "iomanip": "cpp",
+        "iosfwd": "cpp",
+        "iostream": "cpp",
+        "istream": "cpp",
+        "limits": "cpp",
+        "new": "cpp",
+        "ostream": "cpp",
+        "sstream": "cpp",
+        "stdexcept": "cpp",
+        "streambuf": "cpp",
+        "cinttypes": "cpp",
+        "typeinfo": "cpp",
+        "Prooflogger.C": "cpp",
+        "Main.C": "cpp"
+    }
+}
\ No newline at end of file