diff -ruN src_tmp/core/Main.C src/core/Main.C
--- src_tmp/core/Main.C	2022-02-19 16:47:37.927568213 +0100
+++ src/core/Main.C	2022-02-19 12:06:50.626500104 +0100
@@ -26,7 +26,13 @@
 #include <signal.h>
 #include <zlib.h>
 
+// Added for chrono
+#include <iostream>
+#include <chrono>
+#include <string>
+
 #include "Solver.h"
+#include "Prooflogger.h"
 
 /*************************************************************************************/
 #ifdef _MSC_VER
@@ -131,18 +137,18 @@
     return neg ? -val : val; }
 
 template<class B>
-static void readClause(B& in, Solver& S, vec<Lit>& lits, 
+static void readClause(B& in, Solver& S, Prooflogger& PL, vec<Lit>& lits, 
 		       int nbvar, int top, int& nbsoft) { // koshi 10.01.04
 
-    int     parsed_lit, var;
+    int parsed_lit, var, weight;
     lits.clear();
-    parsed_lit = parseInt(in); // koshi 10.01.04
-    if (parsed_lit == 1) { // soft clause
+    weight = parseInt(in); // koshi 10.01.04
+    if (weight == 1) { // soft clause
       nbsoft++;
       lits.push(Lit(S.newVar()));
-    } else if (parsed_lit != top) { // weight of hard clause must be top
+    } else if (weight != top) { // weight of hard clause must be top
       reportf("Unexpected weight %c\n", *in), exit(3);
-    }
+    } else weight = top;
 
     for (;;){
         parsed_lit = parseInt(in);
@@ -163,42 +169,55 @@
 
 
 template<class B>
-static void parse_DIMACS_main(B& in, Solver& S, 
+static void parse_DIMACS_main(B& in, Solver& S, Prooflogger &PL, 
 			      int& out_nbvar, int& out_top, int& out_nbsoft) {
     vec<Lit> lits;
+    int vars, clauses;
+
+    // Read header
+    skipWhitespace(in);
+    while(*in == 'c') skipLine(in);
+    if (*in == 'p'){
+	     if (match(in, "p wcnf")){ // koshi 10.01.04
+            vars    = parseInt(in);            
+            clauses = parseInt(in);            
+		    int top     = parseInt(in);
+		    out_nbvar   = vars;
+		    out_top     = top;
+            reportf("|  Number of variables:    %-12d                                       |\n", vars);
+            reportf("|  Number of clauses:      %-12d                                       |\n", clauses);
+            reportf("|  Weight of hard clauses: %-12d                                       |\n", top);
+		    while (vars > S.nVars()) S.newVar();
+        } else {
+            reportf("PARSE ERROR! Unexpected char: %c\n", *in), exit(3);
+        }
+    } else reportf("PARSE ERROR! No header given!");
+
+    // Read clauses
     for (;;){
         skipWhitespace(in);
         if (*in == EOF)
             break;
-        else if (*in == 'p'){
-	  if (match(in, "p wcnf")){ // koshi 10.01.04
-                int vars    = parseInt(in);
-                int clauses = parseInt(in);
-		int top     = parseInt(in);
-		out_nbvar   = vars;
-		out_top     = top;
-                reportf("|  Number of variables:    %-12d                                       |\n", vars);
-                reportf("|  Number of clauses:      %-12d                                       |\n", clauses);
-                reportf("|  Weight of hard clauses: %-12d                                       |\n", top);
-		while (vars > S.nVars()) S.newVar();
-            }else{
-                reportf("PARSE ERROR! Unexpected char: %c\n", *in), exit(3);
-            }
-        } else if (*in == 'c' || *in == 'p')
-            skipLine(in);
-        else
-	  readClause(in, S, lits, out_nbvar,out_top,out_nbsoft),
+        else if (*in == 'c' || *in == 'p') skipLine(in);
+        else {
+	        readClause(in, S, PL, lits, out_nbvar,out_top,out_nbsoft),
             S.addClause(lits);
+        }
     }
     reportf("|  Number of soft clauses: %-12d                                       |\n", out_nbsoft);
+    PL.n_variables = vars+out_nbsoft;
+    PL.variable_counter = PL.n_variables;
+    PL.formula_length = clauses;
+    PL.constraint_counter = clauses;
+    PL.write_proof_header(clauses);
 }
 
 // Inserts problem into solver.
 //
-static void parse_DIMACS(gzFile input_stream, Solver& S, 
+static void parse_DIMACS(gzFile input_stream, Solver& S, Prooflogger &PL, 
 			 int& out_nbvar, int& out_top, int& out_nbsoft) { // koshi 10.01.04
     StreamBuffer in(input_stream);
-    parse_DIMACS_main(in, S, out_nbvar, out_top, out_nbsoft); }
+    parse_DIMACS_main(in, S, PL, out_nbvar, out_top, out_nbsoft); }
 
 
 //=================================================================================================
@@ -232,10 +251,12 @@
 {
     reportf("USAGE: %s [options] <input-file> <result-output-file>\n\n  where input may be either in plain or gzipped DIMACS.\n\n", argv[0]);
     reportf("OPTIONS:\n\n");
-    reportf("  -polarity-mode = {true,false,rnd}\n");
-    reportf("  -decay         = <num> [ 0 - 1 ]\n");
-    reportf("  -rnd-freq      = <num> [ 0 - 1 ]\n");
-    reportf("  -verbosity     = {0,1,2}\n");
+    reportf("  -polarity-mode       = {true,false,rnd}\n");
+    reportf("  -decay               = <num> [ 0 - 1 ]\n");
+    reportf("  -rnd-freq            = <num> [ 0 - 1 ]\n");
+    reportf("  -verbosity           = {0,1,2}\n");
+    reportf("  -proof-file          = /path/to/proof_file.pbp (default: maxsat_proof.pbp)\n");
+    reportf("  -meaningful_names    = whether or not to assign meaningful names to the auxiliairy variables\n");
     reportf("\n");
 }
 
@@ -251,7 +272,7 @@
 
 // koshi 10.01.08
 void genCardinals(int from, int to, 
-		  Solver& S, vec<Lit>& lits, vec<Lit>& linkingVar) {
+		  Solver& S, Prooflogger& PL, vec<Lit>& lits, vec<Lit>& linkingVar) {
   int inputSize = to - from + 1;
   linkingVar.clear();
 
@@ -261,52 +282,83 @@
   Var varZero = S.newVar();
   Var varLast = S.newVar();
 
+  // First
   lits.clear(); lits.push(Lit(varZero)); S.addClause(lits);
+  PL.write_learnt_clause(lits);
+
+  // Last
   lits.clear(); lits.push(~Lit(varLast)); S.addClause(lits);
+  PL.write_learnt_clause(lits);
+
 
   if (inputSize > 2) {
     int middle = inputSize/2;
-    genCardinals(from, from+middle, S,lits,linkingAlpha);
-    genCardinals(from+middle+1, to, S,lits,linkingBeta);
+    genCardinals(from, from+middle, S,PL,lits,linkingAlpha);
+    genCardinals(from+middle+1, to, S,PL,lits,linkingBeta);
   } else if (inputSize == 2) {
-    genCardinals(from, from, S,lits,linkingAlpha);
-    genCardinals(to, to, S,lits,linkingBeta);
+    genCardinals(from, from, S,PL,lits,linkingAlpha);
+    genCardinals(to, to, S,PL,lits,linkingBeta);
   }
   if (inputSize == 1) {
     linkingVar.push(Lit(varZero));
     linkingVar.push(Lit(from));
     linkingVar.push(Lit(varLast));
   } else { // inputSize >= 2
+
+    PL.write_comment("- Node clauses:");
     linkingVar.push(Lit(varZero));
     for (int i = 0; i < inputSize; i++) linkingVar.push(Lit(S.newVar()));
     linkingVar.push(Lit(varLast));
+
     for (int sigma = 0; sigma <= inputSize; sigma++) {
-      for (int alpha = 0; alpha < linkingAlpha.size()-1; alpha++) {
-	int beta = sigma - alpha;
-	if (0 <= beta && beta < linkingBeta.size()-1) { // create constraints
-	  lits.clear();
-	  lits.push(~linkingAlpha[alpha]);
-	  lits.push(~linkingBeta[beta]);
-	  lits.push(linkingVar[sigma]);
-	  S.addClause(lits);
-	  lits.clear();
-	  lits.push(linkingAlpha[alpha+1]);
-	  lits.push(linkingBeta[beta+1]);
-	  lits.push(~linkingVar[sigma+1]);
-	  S.addClause(lits);
-	}
-      }
+        for (int alpha = 0; alpha < linkingAlpha.size()-1; alpha++) {
+	        int beta = sigma - alpha;
+	        if (0 <= beta && beta < linkingBeta.size()-1) { // create constraints
+	            lits.clear();
+	            lits.push(~linkingAlpha[alpha]);
+	            lits.push(~linkingBeta[beta]);
+	            lits.push(linkingVar[sigma]);
+                PL.write_C1(lits, sigma, from, to);
+	            S.addClause(lits);
+	            lits.clear();
+	            lits.push(linkingAlpha[alpha+1]);
+	            lits.push(linkingBeta[beta+1]);
+	            lits.push(~linkingVar[sigma+1]);
+                PL.write_C2(lits, sigma+1, from, to);
+	            S.addClause(lits);
+	        }
+        }
     }
+    PL.write_comment("-------------------------------------------");
   }
   linkingAlpha.clear();
   linkingBeta.clear();
 }
 
+class MyChrono{
+    public:
+        static std::chrono::time_point<std::chrono::system_clock> startClock(){
+            return std::chrono::system_clock::now();
+        }
+
+        static std::string duration_since(std::chrono::time_point<std::chrono::system_clock>& start){
+            auto end = std::chrono::system_clock::now();
+            std::chrono::duration<double> diff = end - start;
+            
+            return std::to_string(diff.count());
+        }
+
+};
+
 int main(int argc, char** argv)
 {
-    Solver      S;
+    Prooflogger PL;
+    Solver      S(&PL);
     S.verbosity = 1;
 
+    // Duration file
+    bool log_duration_totalizer         = false;
+    const char *duration_file_name      = "totalizer_duration.txt";
 
     int         i, j;
     const char* value;
@@ -347,6 +399,16 @@
             printUsage(argv);
             exit(0);
 
+        } else if ((value = hasPrefix(argv[i], "-proof-file="))) {
+            PL.set_proof_name(value);
+
+        } else if ((value = hasPrefix(argv[i], "-log_duration_totalizer="))) {
+            log_duration_totalizer = true;
+            duration_file_name = value;
+
+        }else if (strcmp(argv[i], "-mn") == 0 || strcmp(argv[i], "-meaningful_names") == 0 || strcmp(argv[i], "--meaningful_names") == 0){
+            PL.meaningful_names = true;
+
         }else if (strncmp(argv[i], "-", 1) == 0){
             reportf("ERROR! unknown flag %s\n", argv[i]);
             exit(0);
@@ -357,7 +419,7 @@
     argc = j;
 
 
-    reportf("This is QMaxSAT 0.1 based on MiniSat 2.0 beta\n");
+    reportf("This is QMaxSAT 0.1 based on MiniSat 2.0 beta, extended for prooflogging\n");
 #if defined(__linux__)
     fpu_control_t oldcw, newcw;
     _FPU_GETCW(oldcw); newcw = (oldcw & ~_FPU_EXTENDED) | _FPU_DOUBLE; _FPU_SETCW(newcw);
@@ -376,6 +438,12 @@
     if (in == NULL)
         reportf("ERROR! Could not open file: %s\n", argc == 1 ? "<stdin>" : argv[1]), exit(1);
 
+    // Open proof file
+    PL.open_proof_file();
+    if (log_duration_totalizer) 
+
+
+
     reportf("============================[ Problem Statistics ]=============================\n");
     reportf("|                                                                             |\n");
 
@@ -383,8 +451,15 @@
     int nbvar  = 0; // number of original variables
     int top    = 0; // weight of hard clause
     int nbsoft = 0; // number of soft clauses
-    parse_DIMACS(in, S, nbvar, top, nbsoft);
+    parse_DIMACS(in, S, PL, nbvar, top, nbsoft);
+    
+    // Initialise PL constraint counter
+    //PL.constraint_counter = S.nClauses();
+
+    // Close input file
     gzclose(in);
+
+    // Open output file
     FILE* res = (argc >= 3) ? fopen(argv[2], "wb") : NULL;
 
     double parse_time = cpuTime() - cpu_time;
@@ -393,6 +468,8 @@
     if (!S.simplify()){
         reportf("Solved by unit propagation\n");
         if (res != NULL) fprintf(res, "UNSAT\n"), fclose(res);
+        PL.write_empty_clause();
+        PL.close_proof_file();
         printf("UNSATISFIABLE\n");
         exit(20);
     }
@@ -406,23 +483,64 @@
     if (ret) { // koshi 09.12.25
       lcnt++;
       int answerNew = 0;
-      for (int i = nbvar; i < nbvar+nbsoft; i++) // count the number of
-	if (S.model[i] == l_True) answerNew++;   // unsatisfied soft clauses
-      if (lcnt == 1) { // first model: generate cardinal constraints
-	genCardinals(nbvar,nbvar+nbsoft-1, S,lits,linkingVar);
-	for (int i = answerNew; i < linkingVar.size()-1; i++) {
-	  lits.clear();
-	  lits.push(~linkingVar[i]);
-	  S.addClause(lits);
-	}
-	answer = answerNew;
+
+      std::chrono::time_point<std::chrono::system_clock> start;
+      
+      for (int i = nbvar; i < nbvar+nbsoft; i++) if (S.model[i] == l_True) answerNew++;   // count the number ofunsatisfied soft clauses
+      if (lcnt == 1) { // first model: generate cardinality constraints
+          PL.write_comment("==============================================================");
+          PL.write_comment("First model found:"); 
+          PL.write_bound_update(S.model);
+          PL.write_comment("==============================================================");
+          PL.write_comment("Cardinality definitions:"); 
+
+          start = MyChrono::startClock();
+
+	      PL.genCardinalDefinitions(nbvar, nbvar+nbsoft-1, lits, linkingVar);
+          
+          auto duration_genCardinalDefinitions = "genCardinalDefinitions: " + MyChrono::duration_since(start) + "s";
+          
+          PL.write_comment("==============================================================");
+          PL.write_comment("Tree derivation:"); 
+	      
+          start = MyChrono::startClock();
+          
+          genCardinals(nbvar,nbvar+nbsoft-1, S, PL, lits, linkingVar);
+          
+          auto duration_genCardinals = "genCardinals: " + MyChrono::duration_since(start) + "s";
+          
+          if(log_duration_totalizer){
+              std::ofstream log_duration_totalizer_stream;
+              log_duration_totalizer_stream.open(duration_file_name);
+              log_duration_totalizer_stream << duration_genCardinalDefinitions << "\n" << duration_genCardinals << "\n";
+              log_duration_totalizer_stream.close();
+          }
+
+          PL.write_comment("==============================================================");
+          PL.write_comment("Constraining through linking variables:"); 
+	      
+           for (int i = answerNew; i < linkingVar.size()-1; i++) {
+	         lits.clear();
+	         lits.push(~linkingVar[i]);
+             PL.write_linkingVar_clause(lits);
+	         S.addClause(lits);
+	       }
+          PL.write_comment("==============================================================");
+          answer = answerNew;
       } else { // lcnt > 1 
-	for (int i = answerNew; i < answer; i++) {
-	  lits.clear();
-	  lits.push(~linkingVar[i]);
-	  S.addClause(lits);
-	}
-	answer = answerNew;
+          PL.write_comment("==============================================================");
+          PL.write_comment("New model found:"); 
+          PL.write_bound_update(S.model);
+          PL.write_comment("==============================================================");
+          PL.write_comment("Constraining through linking variables:"); 
+	       for (int i = answerNew; i < answer; i++) {
+	           lits.clear();
+	           lits.push(~linkingVar[i]);
+               PL.write_linkingVar_clause(lits);
+	           S.addClause(lits);
+	       }
+          PL.write_comment("==============================================================");
+          answer = answerNew;
       }
       reportf("Current answer = %d\n",answer);
       goto solve;
@@ -439,10 +557,11 @@
                 if (S.model[i] != l_Undef)
                     fprintf(res, "%s%s%d", (i==0)?"":" ", (S.model[i]==l_True)?"":"-", i+1);
             fprintf(res, " 0\n");
-        }else
+        } else
             fprintf(res, "UNSAT\n");
         fclose(res);
     }
+    PL.close_proof_file();
 
 #ifdef NDEBUG
     exit(ret ? 10 : 20);     // (faster than "return", which will invoke the destructor for 'Solver')
diff -ruN src_tmp/core/Prooflogger.C src/core/Prooflogger.C
--- src_tmp/core/Prooflogger.C	1970-01-01 01:00:00.000000000 +0100
+++ src/core/Prooflogger.C	2022-02-19 16:47:21.126981223 +0100
@@ -0,0 +1,286 @@
+#include "Prooflogger.h"
+
+//=================================================================================================
+// Proof file
+
+void Prooflogger::write_proof_header(int nbclause) {
+    proof << "pseudo-Boolean proof version 1.0\n";
+    proof << "f " << nbclause << "\n" ;
+}
+
+void Prooflogger::write_comment(const char* comment) {
+    proof<< "* " << comment << "\n" ;
+}
+
+void Prooflogger::write_contradiction() {
+    proof << "c " << constraint_counter << "\n" ;
+}
+
+void Prooflogger::write_empty_clause() {
+    proof<< "u >= 1;\n" ;
+    constraint_counter++;
+    write_contradiction();
+}
+
+bool Prooflogger::is_aux_var(int var) {
+    return var + 1 > n_variables;
+}
+
+std::string Prooflogger::var_name(int var) {
+    std::string name;
+    if(meaningful_names && meaningful_name_UB.find(var) != meaningful_name_UB.end()) {
+        int lb = meaningful_name_LB[var];
+        int ub = meaningful_name_UB[var];
+        int n = meaningful_name_n[var];
+        name = "v" + std::to_string(n) + "_x" + std::to_string(lb) + "_x" + std::to_string(ub); 
+    } else if(is_aux_var(var)) {
+        name = "y";
+        name += std::to_string(var+1);
+    } else {
+        name = "x";
+        name += std::to_string(var+1);
+    } 
+    return name;
+}
+
+void Prooflogger::write_literal(Lit literal) {
+
+    // Weight and sign
+    std::string weight_and_sign = "1 ";
+    weight_and_sign += (sign(literal) == 1 ? "~" : "");
+
+    // Variable symbol
+    std::string name = var_name(var(literal));
+
+    // Write
+    proof << weight_and_sign << name << " " ;
+}
+
+void Prooflogger::write_literal_assignment(lbool assignment, int var) {
+
+    // Sign
+    std::string sign = assignment == l_True? "" : "~";
+
+    // Variable symbol
+    std::string symbol = var_name(var);
+
+    // Write
+    proof << sign << symbol << " " ;
+}
+
+void Prooflogger::write_witness(Lit literal) {
+    std::string name = var_name(var(literal));
+    proof<< name << " -> " << std::to_string(sign(literal) == 0) ;
+}
+
+void Prooflogger::write_clause(vec<Lit>& clause) {
+    for (int i = 0; i < clause.size(); i++) write_literal(clause[i]);
+}
+
+void Prooflogger::write_learnt_clause(vec<Lit>& clause) {
+    proof << "u ";
+    write_clause(clause);
+    proof << " >= 1;\n" ;
+    constraint_counter++;
+}
+
+void Prooflogger::write_linkingVar_clause(vec<Lit>& clause) {
+    int variable = var(clause[0]);
+    int constraint_id = C2_store[variable];
+    if(constraint_id != 0) {
+        proof << "p " << constraint_id << " " << last_bound_constraint_id << " + s\n" ;
+        constraint_counter++;
+    }
+    write_learnt_clause(clause);
+}
+
+void Prooflogger::write_bound_update(vec<lbool>& model) {
+    proof<< "o ";
+    for(int i = 0; i < model.size(); i++) write_literal_assignment(model[i], i);
+    proof << "\n" ;
+
+    // Veripb automatically adds an improvement constraint so counter needs to be incremented
+    last_bound_constraint_id = ++constraint_counter;
+}
+
+void Prooflogger::write_unit_sub_red(vec<Lit>& definition, int sigma, int from, int to) {
+
+    if(meaningful_names) {
+
+        // If variable does not already have a meaningful name
+        if(meaningful_name_LB.find(var(definition[0])) == meaningful_name_LB.end()) {
+            meaningful_name_LB[var(definition[0])] = from+1;
+            meaningful_name_UB[var(definition[0])] = to+1;
+            meaningful_name_n[var(definition[0])] = sigma;
+        }
+    }
+
+    proof << "red ";
+    write_clause(definition);
+    proof << ">= 1; ";
+    write_witness(definition[0]);
+    proof << "\n" ;
+    constraint_counter++;
+}
+
+void Prooflogger::write_P1_sub_red_cardinality(int var, int sigma, int from, int to) {
+
+    if(meaningful_names) {
+
+        // If variable does not already have a meaningful name
+        if(meaningful_name_LB.find(var) == meaningful_name_LB.end()) {
+            meaningful_name_LB[var] = from+1;
+            meaningful_name_UB[var] = to+1;
+            meaningful_name_n[var] = sigma;
+        }
+    }
+
+    int weight = (to-from+1)-(sigma - 1);
+    proof << "red ";
+    for(int i = from; i < to+1; i++) {
+        write_literal(~Lit(i));
+    }
+    proof << weight << " " << var_name(var) << " >= " << weight << "; ";
+    write_witness(Lit(var));
+    proof << "\n" ;
+    constraint_counter++;
+    C1_store[var] = constraint_counter;
+}
+
+void Prooflogger::write_P2_sub_red_cardinality(int var, int sigma, int from, int to) {
+
+    if(meaningful_names) {
+
+        // If variable does not already have a meaningful name
+        if(meaningful_name_LB.find(var) == meaningful_name_LB.end()) {
+            meaningful_name_LB[var] = from+1;
+            meaningful_name_UB[var] = to+1;
+            meaningful_name_n[var] = sigma;
+        }
+    }
+
+    int weight = sigma;
+    proof << "red ";
+    for(int i = from; i < to+1; i++) {
+        write_literal(Lit(i));
+    }
+    proof << weight << " ~" << var_name(var) << " >= " << weight << "; ";
+    write_witness(~Lit(var));
+    proof << "\n" ;
+    constraint_counter++;
+    C2_store[var] = constraint_counter;
+}
+
+void Prooflogger::write_C1(vec<Lit>& definition, int sigma, int from, int to) {
+    int first = var(definition[0]);
+    int second = var(definition[1]);
+    int third = var(definition[2]);
+
+    // Write derivation of parts
+    bool resolved_one = false;
+    if(C2_store.find(first) != C2_store.end()) {
+        resolved_one = true;
+        proof << "p " << C1_store[third] << " " << C2_store[first] << " +\n" ;
+        constraint_counter++;
+    }
+    if(C2_store.find(second) != C2_store.end()) {
+        int to_add_to = resolved_one? constraint_counter : C1_store[third];
+        proof << "p " << to_add_to << " " << C2_store[second] << " +\n" ;
+        constraint_counter++;
+        resolved_one = true;
+    }
+    if(resolved_one) {
+        proof << "p " << constraint_counter << " s\n" ;
+        constraint_counter++;
+    }
+
+    // Derivation is done so clause can be written as RUP
+    write_learnt_clause(definition);
+}
+
+void Prooflogger::write_C2(vec<Lit>& definition, int sigma, int from, int to) {
+    int first = var(definition[0]);
+    int second = var(definition[1]);
+    int third = var(definition[2]);
+
+    // Write derivation of parts
+    bool resolved_one = false;
+    if(C1_store.find(first) != C1_store.end()) {
+        resolved_one = true;
+        proof << "p " << C2_store[third] << " " << C1_store[first] << " +\n" ;
+        constraint_counter++;
+    }
+    if(C1_store.find(second) != C1_store.end()) {
+        int to_add_to = resolved_one? constraint_counter : C2_store[third];
+        proof << "p " << to_add_to << " " << C1_store[second] << " +\n" ;
+        constraint_counter++;
+        resolved_one = true;
+    }
+    if(resolved_one) {
+        proof << "p " << constraint_counter << " 2 d s\n" ;
+        constraint_counter++;
+    }
+
+    // Derivation is done so clause can be written as RUP
+    write_learnt_clause(definition);
+}
+
+void Prooflogger::genCardinalDefinitions(int from, int to, vec<Lit>& lits, vec<Lit>& linkingVar) {
+  int inputSize = to - from + 1;
+  linkingVar.clear();
+
+  vec<Lit> linkingAlpha;
+  vec<Lit> linkingBeta;
+
+  Var varZero = variable_counter++;
+  Var varLast = variable_counter++;
+
+  // First
+  lits.clear(); lits.push(Lit(varZero));
+  write_unit_sub_red(lits, 0, from, to);
+
+  // Last
+  lits.clear(); lits.push(~Lit(varLast));
+  write_unit_sub_red(lits, inputSize+1, from, to);
+
+
+  if (inputSize > 2) {
+    int middle = inputSize/2;
+    genCardinalDefinitions(from, from+middle, lits, linkingAlpha);
+    genCardinalDefinitions(from+middle+1, to, lits, linkingBeta);
+  } else if (inputSize == 2) {
+    genCardinalDefinitions(from, from, lits, linkingAlpha);
+    genCardinalDefinitions(to, to, lits, linkingBeta);
+  }
+  if (inputSize == 1) {
+    linkingVar.push(Lit(varZero));
+    linkingVar.push(Lit(from));
+    linkingVar.push(Lit(varLast));
+  } else { // inputSize >= 2
+
+    write_comment("- Node clauses:");
+    linkingVar.push(Lit(varZero));
+    for (int i = 0; i < inputSize; i++) linkingVar.push(Lit(variable_counter++));
+    linkingVar.push(Lit(varLast));
+
+    for (int sigma = 0; sigma <= inputSize; sigma++) {
+
+        // Verify if PB cardinality definition exists
+        if(C1_store.find(var(linkingVar[sigma])) == C1_store.end()) {
+
+            // Write a substitution redundancy PB cardinality definition
+            write_P1_sub_red_cardinality(var(linkingVar[sigma]), sigma, from, to);
+        }
+
+        // Verify if PB cardinality definition exists
+        if(C2_store.find(var(~linkingVar[sigma+1])) == C2_store.end()) {
+
+            // Write a substitution redundancy PB cardinality definition
+            write_P2_sub_red_cardinality(var(~linkingVar[sigma+1]), sigma+1, from, to);
+        }
+    }
+    write_comment("-------------------------------------------");
+  }
+  linkingAlpha.clear();
+  linkingBeta.clear();
+}
\ No newline at end of file
diff -ruN src_tmp/core/Prooflogger.h src/core/Prooflogger.h
--- src_tmp/core/Prooflogger.h	1970-01-01 01:00:00.000000000 +0100
+++ src/core/Prooflogger.h	2022-02-19 12:06:50.626500104 +0100
@@ -0,0 +1,79 @@
+#ifndef Prooflogger_h
+#define Prooflogger_h
+
+#include <cstdio>
+#include <fstream>
+#include <iostream>
+#include <sstream>
+#include <map>
+#include <string>
+#include <regex>
+
+#include "Vec.h"
+#include "Heap.h"
+#include "Alg.h"
+
+#include "SolverTypes.h"
+
+//=================================================================================================
+// Prooflogger 
+
+
+class Prooflogger {
+public:
+
+    // Formula information
+    //
+    int formula_length = 0;
+    int n_variables = 0;
+
+    // Constraint counter
+    //
+    int constraint_counter = 0;
+    int last_bound_constraint_id;
+
+    // Tree derivation
+    //
+    int variable_counter = 0;
+
+    // Meaningful variable names
+    bool meaningful_names = false;
+    std::map<int, int> meaningful_name_LB;
+    std::map<int, int> meaningful_name_UB;
+    std::map<int, int> meaningful_name_n;
+
+    // Constraint stores
+    //
+    std::map<int, int> C1_store;
+    std::map<int, int> C2_store;
+
+    // Proof file
+    std::ofstream proof;
+    const char *proof_file_name         = "maxsat_proof.pbp";
+    void set_proof_name                 (const char* name) {proof_file_name = name;};
+    void open_proof_file                (){proof.open(proof_file_name);};
+    void close_proof_file               (){proof.close();};
+    void write_tree_derivation          ();
+    void write_proof_header             (int nbclause);
+    void write_comment                  (const char* comment);
+    void write_contradiction            ();
+    void write_empty_clause             ();
+    bool is_aux_var                     (int var); 
+    std::string var_name                (int var); 
+    void write_literal                  (Lit literal);
+    void write_literal_assignment       (lbool assignment, int var);
+    void write_witness                  (Lit literal);
+    void write_clause                   (vec<Lit>& clause);
+    void write_learnt_clause            (vec<Lit>& clause);
+    void write_linkingVar_clause        (vec<Lit>& clause);
+    void write_bound_update             (vec<lbool>& model); 
+    void write_unit_sub_red             (vec<Lit>& definition, int sigma, int from, int to);
+    void write_C1                       (vec<Lit>& definition, int sigma, int from, int to);
+    void write_P1_sub_red_cardinality   (int var, int sigma, int from, int to);
+    void write_C2                       (vec<Lit>& definition, int sigma, int from, int to);
+    void write_P2_sub_red_cardinality   (int var, int sigma, int from, int to);
+    void genCardinalDefinitions         (int from, int to, vec<Lit>& lits, vec<Lit>& linkingVar); 
+};
+
+//=================================================================================================
+#endif
\ No newline at end of file
diff -ruN src_tmp/core/Solver.C src/core/Solver.C
--- src_tmp/core/Solver.C	2022-02-19 16:47:37.927568213 +0100
+++ src/core/Solver.C	2022-02-19 12:06:50.626500104 +0100
@@ -26,7 +26,7 @@
 // Constructor/Destructor:
 
 
-Solver::Solver() :
+Solver::Solver(Prooflogger *PL) :
 
     // Parameters: (formerly in 'SearchParams')
     var_decay(1 / 0.95), clause_decay(1 / 0.999), random_var_freq(0.02)
@@ -53,6 +53,10 @@
   , random_seed      (91648253)
   , progress_estimate(0)
   , remove_satisfied (true)
+
+  // Prooflogger
+  //
+  , PL(PL)
 {}
 
 
@@ -544,7 +548,7 @@
 |    all variables are decision variables, this means that the clause set is satisfiable. 'l_False'
 |    if the clause set is unsatisfiable. 'l_Undef' if the bound on number of conflicts is reached.
 |________________________________________________________________________________________________@*/
-lbool Solver::search(int nof_conflicts, int nof_learnts)
+lbool Solver::search(int nof_conflicts, int nof_learnts) 
 {
     assert(ok);
     int         backtrack_level;
@@ -560,12 +564,19 @@
         if (confl != NULL){
             // CONFLICT
             conflicts++; conflictC++;
-            if (decisionLevel() == 0) return l_False;
+            if (decisionLevel() == 0) {
+                PL->write_empty_clause();
+                return l_False;
+            }
 
             first = false;
 
             learnt_clause.clear();
             analyze(confl, learnt_clause, backtrack_level);
+
+            // Write the learnt clause to the proof file
+            PL->write_learnt_clause(learnt_clause);
+
             cancelUntil(backtrack_level);
             assert(value(learnt_clause[0]) == l_Undef);
 
@@ -592,8 +603,10 @@
                 return l_Undef; }
 
             // Simplify the set of problem clauses:
-            if (decisionLevel() == 0 && !simplify())
+            if (decisionLevel() == 0 && !simplify()) {
+                PL->write_empty_clause();
                 return l_False;
+            }
 
             if (nof_learnts >= 0 && learnts.size()-nAssigns() >= nof_learnts)
                 // Reduce the set of learnt clauses:
@@ -654,7 +667,10 @@
     model.clear();
     conflict.clear();
 
-    if (!ok) return false;
+    if (!ok) {
+        PL->write_empty_clause();
+        return false;
+    }
 
     assumps.copyTo(assumptions);
 
diff -ruN src_tmp/core/Solver.h src/core/Solver.h
--- src_tmp/core/Solver.h	2022-02-19 16:47:37.927568213 +0100
+++ src/core/Solver.h	2022-02-19 12:06:50.626500104 +0100
@@ -21,12 +21,15 @@
 #define Solver_h
 
 #include <cstdio>
+#include <fstream>
+#include <iostream>
 
 #include "Vec.h"
 #include "Heap.h"
 #include "Alg.h"
 
 #include "SolverTypes.h"
+#include "Prooflogger.h"
 
 
 //=================================================================================================
@@ -38,9 +41,13 @@
 
     // Constructor/Destructor:
     //
-    Solver();
+    Solver(Prooflogger *PL);
     ~Solver();
 
+    // Proof logging:
+    //
+    Prooflogger* PL;
+
     // Problem specification:
     //
     Var     newVar    (bool polarity = true, bool dvar = true); // Add a new variable with parameters specifying variable mode.
@@ -146,19 +153,19 @@
 
     // Main internal methods:
     //
-    void     insertVarOrder   (Var x);                                                 // Insert a variable in the decision order priority queue.
-    Lit      pickBranchLit    (int polarity_mode, double random_var_freq);             // Return the next decision variable.
-    void     newDecisionLevel ();                                                      // Begins a new decision level.
-    void     uncheckedEnqueue (Lit p, Clause* from = NULL);                            // Enqueue a literal. Assumes value of literal is undefined.
-    bool     enqueue          (Lit p, Clause* from = NULL);                            // Test if fact 'p' contradicts current state, enqueue otherwise.
-    Clause*  propagate        ();                                                      // Perform unit propagation. Returns possibly conflicting clause.
-    void     cancelUntil      (int level);                                             // Backtrack until a certain level.
-    void     analyze          (Clause* confl, vec<Lit>& out_learnt, int& out_btlevel); // (bt = backtrack)
-    void     analyzeFinal     (Lit p, vec<Lit>& out_conflict);                         // COULD THIS BE IMPLEMENTED BY THE ORDINARIY "analyze" BY SOME REASONABLE GENERALIZATION?
-    bool     litRedundant     (Lit p, uint32_t abstract_levels);                       // (helper method for 'analyze()')
-    lbool    search           (int nof_conflicts, int nof_learnts);                    // Search for a given number of conflicts.
-    void     reduceDB         ();                                                      // Reduce the set of learnt clauses.
-    void     removeSatisfied  (vec<Clause*>& cs);                                      // Shrink 'cs' to contain only non-satisfied clauses.
+    void     insertVarOrder   (Var x);                                                  // Insert a variable in the decision order priority queue.
+    Lit      pickBranchLit    (int polarity_mode, double random_var_freq);              // Return the next decision variable.
+    void     newDecisionLevel ();                                                       // Begins a new decision level.
+    void     uncheckedEnqueue (Lit p, Clause* from = NULL);                             // Enqueue a literal. Assumes value of literal is undefined.
+    bool     enqueue          (Lit p, Clause* from = NULL);                             // Test if fact 'p' contradicts current state, enqueue otherwise.
+    Clause*  propagate        ();                                                       // Perform unit propagation. Returns possibly conflicting clause.
+    void     cancelUntil      (int level);                                              // Backtrack until a certain level.
+    void     analyze          (Clause* confl, vec<Lit>& out_learnt, int& out_btlevel);  // (bt = backtrack)
+    void     analyzeFinal     (Lit p, vec<Lit>& out_conflict);                          // COULD THIS BE IMPLEMENTED BY THE ORDINARIY "analyze" BY SOME REASONABLE GENERALIZATION?
+    bool     litRedundant     (Lit p, uint32_t abstract_levels);                        // (helper method for 'analyze()')
+    lbool    search           (int nof_conflicts, int nof_learnts);                     // Search for a given number of conflicts.
+    void     reduceDB         ();                                                       // Reduce the set of learnt clauses.
+    void     removeSatisfied  (vec<Clause*>& cs);                                       // Shrink 'cs' to contain only non-satisfied clauses.
 
     // Maintaining Variable/Clause activity:
     //
diff -ruN src_tmp/minisat/core/depend.mk src/minisat/core/depend.mk
--- src_tmp/minisat/core/depend.mk	1970-01-01 01:00:00.000000000 +0100
+++ src/minisat/core/depend.mk	2022-02-19 12:06:50.626500104 +0100
@@ -0,0 +1,16 @@
+Main.o: Main.C Solver.h ../mtl/Vec.h ../mtl/Heap.h ../mtl/Vec.h \
+ ../mtl/Alg.h SolverTypes.h
+Solver.o: Solver.C Solver.h ../mtl/Vec.h ../mtl/Heap.h ../mtl/Vec.h \
+ ../mtl/Alg.h SolverTypes.h ../mtl/Sort.h
+Main.op: Main.C Solver.h ../mtl/Vec.h ../mtl/Heap.h ../mtl/Vec.h \
+ ../mtl/Alg.h SolverTypes.h
+Solver.op: Solver.C Solver.h ../mtl/Vec.h ../mtl/Heap.h ../mtl/Vec.h \
+ ../mtl/Alg.h SolverTypes.h ../mtl/Sort.h
+Main.od: Main.C Solver.h ../mtl/Vec.h ../mtl/Heap.h ../mtl/Vec.h \
+ ../mtl/Alg.h SolverTypes.h
+Solver.od: Solver.C Solver.h ../mtl/Vec.h ../mtl/Heap.h ../mtl/Vec.h \
+ ../mtl/Alg.h SolverTypes.h ../mtl/Sort.h
+Main.or: Main.C Solver.h ../mtl/Vec.h ../mtl/Heap.h ../mtl/Vec.h \
+ ../mtl/Alg.h SolverTypes.h
+Solver.or: Solver.C Solver.h ../mtl/Vec.h ../mtl/Heap.h ../mtl/Vec.h \
+ ../mtl/Alg.h SolverTypes.h ../mtl/Sort.h
diff -ruN src_tmp/minisat/core/Dimacs.h src/minisat/core/Dimacs.h
--- src_tmp/minisat/core/Dimacs.h	1970-01-01 01:00:00.000000000 +0100
+++ src/minisat/core/Dimacs.h	2022-02-19 12:06:50.626500104 +0100
@@ -0,0 +1,89 @@
+/****************************************************************************************[Dimacs.h]
+Copyright (c) 2003-2006, Niklas Een, Niklas Sorensson
+Copyright (c) 2007-2010, Niklas Sorensson
+
+Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
+associated documentation files (the "Software"), to deal in the Software without restriction,
+including without limitation the rights to use, copy, modify, merge, publish, distribute,
+sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all copies or
+substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
+NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT
+OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+**************************************************************************************************/
+
+#ifndef Minisat_Dimacs_h
+#define Minisat_Dimacs_h
+
+#include <stdio.h>
+
+#include "utils/ParseUtils.h"
+#include "core/SolverTypes.h"
+
+namespace Minisat {
+
+//=================================================================================================
+// DIMACS Parser:
+
+template<class B, class Solver>
+static void readClause(B& in, Solver& S, vec<Lit>& lits) {
+    int     parsed_lit, var;
+    lits.clear();
+    for (;;){
+        parsed_lit = parseInt(in);
+        if (parsed_lit == 0) break;
+        var = abs(parsed_lit)-1;
+        while (var >= S.nVars()) S.newVar();
+        lits.push( (parsed_lit > 0) ? mkLit(var) : ~mkLit(var) );
+    }
+}
+
+template<class B, class Solver>
+static void parse_DIMACS_main(B& in, Solver& S) {
+    vec<Lit> lits;
+    int vars    = 0;
+    int clauses = 0;
+    int cnt     = 0;
+    for (;;){
+        skipWhitespace(in);
+        if (*in == EOF) break;
+        else if (*in == 'p'){
+            if (eagerMatch(in, "p cnf")){
+                vars    = parseInt(in);
+                clauses = parseInt(in);
+                // SATRACE'06 hack
+                // if (clauses > 4000000)
+                //     S.eliminate(true);
+            }else{
+                printf("PARSE ERROR! Unexpected char: %c\n", *in), exit(3);
+            }
+        } else if (*in == 'c' || *in == 'p')
+            skipLine(in);
+        else{
+            cnt++;
+            readClause(in, S, lits);
+            S.addClause_(lits); }
+    }
+    if (vars != S.nVars())
+        fprintf(stderr, "WARNING! DIMACS header mismatch: wrong number of variables.\n");
+    if (cnt  != clauses)
+        fprintf(stderr, "WARNING! DIMACS header mismatch: wrong number of clauses.\n");
+}
+
+// Inserts problem into solver.
+//
+template<class Solver>
+static void parse_DIMACS(gzFile input_stream, Solver& S) {
+    StreamBuffer in(input_stream);
+    parse_DIMACS_main(in, S); }
+
+//=================================================================================================
+}
+
+#endif
diff -ruN src_tmp/minisat/core/Main.C src/minisat/core/Main.C
--- src_tmp/minisat/core/Main.C	1970-01-01 01:00:00.000000000 +0100
+++ src/minisat/core/Main.C	2022-02-19 12:06:50.626500104 +0100
@@ -0,0 +1,450 @@
+/******************************************************************************************[Main.C]
+QMaxSAT -- Copyright (c) 2010-2011, Miyuki Koshimura
+MiniSat -- Copyright (c) 2003-2006, Niklas Een, Niklas Sorensson
+
+Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
+associated documentation files (the "Software"), to deal in the Software without restriction,
+including without limitation the rights to use, copy, modify, merge, publish, distribute,
+sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all copies or
+substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
+NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT
+OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+**************************************************************************************************/
+
+#include <ctime>
+#include <cstring>
+#include <stdint.h>
+#include <errno.h>
+
+#include <signal.h>
+#include <zlib.h>
+
+#include "Solver.h"
+
+/*************************************************************************************/
+#ifdef _MSC_VER
+#include <ctime>
+
+static inline double cpuTime(void) {
+    return (double)clock() / CLOCKS_PER_SEC; }
+#else
+
+#include <sys/time.h>
+#include <sys/resource.h>
+#include <unistd.h>
+
+static inline double cpuTime(void) {
+    struct rusage ru;
+    getrusage(RUSAGE_SELF, &ru);
+    return (double)ru.ru_utime.tv_sec + (double)ru.ru_utime.tv_usec / 1000000; }
+#endif
+
+
+#if defined(__linux__)
+static inline int memReadStat(int field)
+{
+    char    name[256];
+    pid_t pid = getpid();
+    sprintf(name, "/proc/%d/statm", pid);
+    FILE*   in = fopen(name, "rb");
+    if (in == NULL) return 0;
+    int     value;
+    for (; field >= 0; field--)
+        fscanf(in, "%d", &value);
+    fclose(in);
+    return value;
+}
+static inline uint64_t memUsed() { return (uint64_t)memReadStat(0) * (uint64_t)getpagesize(); }
+
+
+#elif defined(__FreeBSD__)
+static inline uint64_t memUsed(void) {
+    struct rusage ru;
+    getrusage(RUSAGE_SELF, &ru);
+    return ru.ru_maxrss*1024; }
+
+
+#else
+static inline uint64_t memUsed() { return 0; }
+#endif
+
+#if defined(__linux__)
+#include <fpu_control.h>
+#endif
+
+//=================================================================================================
+// DIMACS Parser:
+
+#define CHUNK_LIMIT 1048576
+
+class StreamBuffer {
+    gzFile  in;
+    char    buf[CHUNK_LIMIT];
+    int     pos;
+    int     size;
+
+    void assureLookahead() {
+        if (pos >= size) {
+            pos  = 0;
+            size = gzread(in, buf, sizeof(buf)); } }
+
+public:
+    StreamBuffer(gzFile i) : in(i), pos(0), size(0) {
+        assureLookahead(); }
+
+    int  operator *  () { return (pos >= size) ? EOF : buf[pos]; }
+    void operator ++ () { pos++; assureLookahead(); }
+};
+
+//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+
+template<class B>
+static void skipWhitespace(B& in) {
+    while ((*in >= 9 && *in <= 13) || *in == 32)
+        ++in; }
+
+template<class B>
+static void skipLine(B& in) {
+    for (;;){
+        if (*in == EOF || *in == '\0') return;
+        if (*in == '\n') { ++in; return; }
+        ++in; } }
+
+template<class B>
+static int parseInt(B& in) {
+    int     val = 0;
+    bool    neg = false;
+    skipWhitespace(in);
+    if      (*in == '-') neg = true, ++in;
+    else if (*in == '+') ++in;
+    if (*in < '0' || *in > '9') reportf("PARSE ERROR! Unexpected char: %c\n", *in), exit(3);
+    while (*in >= '0' && *in <= '9')
+        val = val*10 + (*in - '0'),
+        ++in;
+    return neg ? -val : val; }
+
+template<class B>
+static void readClause(B& in, Solver& S, vec<Lit>& lits, 
+		       int nbvar, int top, int& nbsoft) { // koshi 10.01.04
+
+    int     parsed_lit, var;
+    lits.clear();
+    parsed_lit = parseInt(in); // koshi 10.01.04
+    if (parsed_lit == 1) { // soft clause
+      nbsoft++;
+      lits.push(Lit(S.newVar()));
+    } else if (parsed_lit != top) { // weight of hard clause must be top
+      reportf("Unexpected weight %c\n", *in), exit(3);
+    }
+
+    for (;;){
+        parsed_lit = parseInt(in);
+        if (parsed_lit == 0) break;
+        var = abs(parsed_lit)-1;
+	// koshi 10.01.04        while (var >= S.nVars()) S.newVar();
+        lits.push( (parsed_lit > 0) ? Lit(var) : ~Lit(var) );
+    }
+}
+
+template<class B>
+static bool match(B& in, char* str) {
+    for (; *str != 0; ++str, ++in)
+        if (*str != *in)
+            return false;
+    return true;
+}
+
+
+template<class B>
+static void parse_DIMACS_main(B& in, Solver& S, 
+			      int& out_nbvar, int& out_top, int& out_nbsoft) {
+    vec<Lit> lits;
+    for (;;){
+        skipWhitespace(in);
+        if (*in == EOF)
+            break;
+        else if (*in == 'p'){
+	  if (match(in, "p wcnf")){ // koshi 10.01.04
+                int vars    = parseInt(in);
+                int clauses = parseInt(in);
+		int top     = parseInt(in);
+		out_nbvar   = vars;
+		out_top     = top;
+                reportf("|  Number of variables:    %-12d                                       |\n", vars);
+                reportf("|  Number of clauses:      %-12d                                       |\n", clauses);
+                reportf("|  Weight of hard clauses: %-12d                                       |\n", top);
+		while (vars > S.nVars()) S.newVar();
+            }else{
+                reportf("PARSE ERROR! Unexpected char: %c\n", *in), exit(3);
+            }
+        } else if (*in == 'c' || *in == 'p')
+            skipLine(in);
+        else
+	  readClause(in, S, lits, out_nbvar,out_top,out_nbsoft),
+            S.addClause(lits);
+    }
+    reportf("|  Number of soft clauses: %-12d                                       |\n", out_nbsoft);
+}
+
+// Inserts problem into solver.
+//
+static void parse_DIMACS(gzFile input_stream, Solver& S, 
+			 int& out_nbvar, int& out_top, int& out_nbsoft) { // koshi 10.01.04
+    StreamBuffer in(input_stream);
+    parse_DIMACS_main(in, S, out_nbvar, out_top, out_nbsoft); }
+
+
+//=================================================================================================
+
+
+void printStats(Solver& solver)
+{
+    double   cpu_time = cpuTime();
+    uint64_t mem_used = memUsed();
+    reportf("restarts              : %lld\n", solver.starts);
+    reportf("conflicts             : %-12lld   (%.0f /sec)\n", solver.conflicts   , solver.conflicts   /cpu_time);
+    reportf("decisions             : %-12lld   (%4.2f %% random) (%.0f /sec)\n", solver.decisions, (float)solver.rnd_decisions*100 / (float)solver.decisions, solver.decisions   /cpu_time);
+    reportf("propagations          : %-12lld   (%.0f /sec)\n", solver.propagations, solver.propagations/cpu_time);
+    reportf("conflict literals     : %-12lld   (%4.2f %% deleted)\n", solver.tot_literals, (solver.max_literals - solver.tot_literals)*100 / (double)solver.max_literals);
+    if (mem_used != 0) reportf("Memory used           : %.2f MB\n", mem_used / 1048576.0);
+    reportf("CPU time              : %g s\n", cpu_time);
+}
+
+Solver* solver;
+static void SIGINT_handler(int signum) {
+    reportf("\n"); reportf("*** INTERRUPTED ***\n");
+    printStats(*solver);
+    reportf("\n"); reportf("*** INTERRUPTED ***\n");
+    exit(1); }
+
+
+//=================================================================================================
+// Main:
+
+void printUsage(char** argv)
+{
+    reportf("USAGE: %s [options] <input-file> <result-output-file>\n\n  where input may be either in plain or gzipped DIMACS.\n\n", argv[0]);
+    reportf("OPTIONS:\n\n");
+    reportf("  -polarity-mode = {true,false,rnd}\n");
+    reportf("  -decay         = <num> [ 0 - 1 ]\n");
+    reportf("  -rnd-freq      = <num> [ 0 - 1 ]\n");
+    reportf("  -verbosity     = {0,1,2}\n");
+    reportf("\n");
+}
+
+
+const char* hasPrefix(const char* str, const char* prefix)
+{
+    int len = strlen(prefix);
+    if (strncmp(str, prefix, len) == 0)
+        return str + len;
+    else
+        return NULL;
+}
+
+// koshi 10.01.08
+void genCardinals(int from, int to, 
+		  Solver& S, vec<Lit>& lits, vec<Lit>& linkingVar) {
+  int inputSize = to - from + 1;
+  linkingVar.clear();
+
+  vec<Lit> linkingAlpha;
+  vec<Lit> linkingBeta;
+
+  Var varZero = S.newVar();
+  Var varLast = S.newVar();
+
+  lits.clear(); lits.push(Lit(varZero)); S.addClause(lits);
+  lits.clear(); lits.push(~Lit(varLast)); S.addClause(lits);
+
+  if (inputSize > 2) {
+    int middle = inputSize/2;
+    genCardinals(from, from+middle, S,lits,linkingAlpha);
+    genCardinals(from+middle+1, to, S,lits,linkingBeta);
+  } else if (inputSize == 2) {
+    genCardinals(from, from, S,lits,linkingAlpha);
+    genCardinals(to, to, S,lits,linkingBeta);
+  }
+  if (inputSize == 1) {
+    linkingVar.push(Lit(varZero));
+    linkingVar.push(Lit(from));
+    linkingVar.push(Lit(varLast));
+  } else { // inputSize >= 2
+    linkingVar.push(Lit(varZero));
+    for (int i = 0; i < inputSize; i++) linkingVar.push(Lit(S.newVar()));
+    linkingVar.push(Lit(varLast));
+    for (int sigma = 0; sigma <= inputSize; sigma++) {
+      for (int alpha = 0; alpha < linkingAlpha.size()-1; alpha++) {
+	int beta = sigma - alpha;
+	if (0 <= beta && beta < linkingBeta.size()-1) { // create constraints
+	  lits.clear();
+	  lits.push(~linkingAlpha[alpha]);
+	  lits.push(~linkingBeta[beta]);
+	  lits.push(linkingVar[sigma]);
+	  S.addClause(lits);
+	  lits.clear();
+	  lits.push(linkingAlpha[alpha+1]);
+	  lits.push(linkingBeta[beta+1]);
+	  lits.push(~linkingVar[sigma+1]);
+	  S.addClause(lits);
+	}
+      }
+    }
+  }
+  linkingAlpha.clear();
+  linkingBeta.clear();
+}
+
+int main(int argc, char** argv)
+{
+    Solver      S;
+    S.verbosity = 1;
+
+
+    int         i, j;
+    const char* value;
+    for (i = j = 0; i < argc; i++){
+        if ((value = hasPrefix(argv[i], "-polarity-mode="))){
+            if (strcmp(value, "true") == 0)
+                S.polarity_mode = Solver::polarity_true;
+            else if (strcmp(value, "false") == 0)
+                S.polarity_mode = Solver::polarity_false;
+            else if (strcmp(value, "rnd") == 0)
+                S.polarity_mode = Solver::polarity_rnd;
+            else{
+                reportf("ERROR! unknown polarity-mode %s\n", value);
+                exit(0); }
+
+        }else if ((value = hasPrefix(argv[i], "-rnd-freq="))){
+            double rnd;
+            if (sscanf(value, "%lf", &rnd) <= 0 || rnd < 0 || rnd > 1){
+                reportf("ERROR! illegal rnd-freq constant %s\n", value);
+                exit(0); }
+            S.random_var_freq = rnd;
+
+        }else if ((value = hasPrefix(argv[i], "-decay="))){
+            double decay;
+            if (sscanf(value, "%lf", &decay) <= 0 || decay <= 0 || decay > 1){
+                reportf("ERROR! illegal decay constant %s\n", value);
+                exit(0); }
+            S.var_decay = 1 / decay;
+
+        }else if ((value = hasPrefix(argv[i], "-verbosity="))){
+            int verbosity = (int)strtol(value, NULL, 10);
+            if (verbosity == 0 && errno == EINVAL){
+                reportf("ERROR! illegal verbosity level %s\n", value);
+                exit(0); }
+            S.verbosity = verbosity;
+
+        }else if (strcmp(argv[i], "-h") == 0 || strcmp(argv[i], "-help") == 0 || strcmp(argv[i], "--help") == 0){
+            printUsage(argv);
+            exit(0);
+
+        }else if (strncmp(argv[i], "-", 1) == 0){
+            reportf("ERROR! unknown flag %s\n", argv[i]);
+            exit(0);
+
+        }else
+            argv[j++] = argv[i];
+    }
+    argc = j;
+
+
+    reportf("This is QMaxSAT 0.1 based on MiniSat 2.0 beta\n");
+#if defined(__linux__)
+    fpu_control_t oldcw, newcw;
+    _FPU_GETCW(oldcw); newcw = (oldcw & ~_FPU_EXTENDED) | _FPU_DOUBLE; _FPU_SETCW(newcw);
+    reportf("WARNING: for repeatability, setting FPU to use double precision\n");
+#endif
+    double cpu_time = cpuTime();
+
+    solver = &S;
+    signal(SIGINT,SIGINT_handler);
+    signal(SIGHUP,SIGINT_handler);
+
+    if (argc == 1)
+        reportf("Reading from standard input... Use '-h' or '--help' for help.\n");
+
+    gzFile in = (argc == 1) ? gzdopen(0, "rb") : gzopen(argv[1], "rb");
+    if (in == NULL)
+        reportf("ERROR! Could not open file: %s\n", argc == 1 ? "<stdin>" : argv[1]), exit(1);
+
+    reportf("============================[ Problem Statistics ]=============================\n");
+    reportf("|                                                                             |\n");
+
+    // koshi 10.01.04 
+    int nbvar  = 0; // number of original variables
+    int top    = 0; // weight of hard clause
+    int nbsoft = 0; // number of soft clauses
+    parse_DIMACS(in, S, nbvar, top, nbsoft);
+    gzclose(in);
+    FILE* res = (argc >= 3) ? fopen(argv[2], "wb") : NULL;
+
+    double parse_time = cpuTime() - cpu_time;
+    reportf("|  Parsing time:         %-12.2f s                                       |\n", parse_time);
+
+    if (!S.simplify()){
+        reportf("Solved by unit propagation\n");
+        if (res != NULL) fprintf(res, "UNSAT\n"), fclose(res);
+        printf("UNSATISFIABLE\n");
+        exit(20);
+    }
+
+    int answer = nbsoft; // koshi 10.01.04
+    vec<Lit> lits;
+    int lcnt = 0; // loop count
+    vec<Lit> linkingVar;
+ solve:
+    bool ret = S.solve();
+    if (ret) { // koshi 09.12.25
+      lcnt++;
+      int answerNew = 0;
+      for (int i = nbvar; i < nbvar+nbsoft; i++) // count the number of
+	if (S.model[i] == l_True) answerNew++;   // unsatisfied soft clauses
+      if (lcnt == 1) { // first model: generate cardinal constraints
+	genCardinals(nbvar,nbvar+nbsoft-1, S,lits,linkingVar);
+	for (int i = answerNew; i < linkingVar.size()-1; i++) {
+	  lits.clear();
+	  lits.push(~linkingVar[i]);
+	  S.addClause(lits);
+	}
+	answer = answerNew;
+      } else { // lcnt > 1 
+	for (int i = answerNew; i < answer; i++) {
+	  lits.clear();
+	  lits.push(~linkingVar[i]);
+	  S.addClause(lits);
+	}
+	answer = answerNew;
+      }
+      reportf("Current answer = %d\n",answer);
+      goto solve;
+    }
+    printStats(S);
+    reportf("\n");
+    //    printf(ret ? "SATISFIABLE\n" : "UNSATISFIABLE\n");
+    if (lcnt > 0 ) printf("Answer = %d by %d loops\n",answer,lcnt);
+    else printf("Unsatisfiable\n");
+    if (res != NULL){
+        if (ret){
+            fprintf(res, "SAT\n");
+            for (int i = 0; i < S.nVars(); i++)
+                if (S.model[i] != l_Undef)
+                    fprintf(res, "%s%s%d", (i==0)?"":" ", (S.model[i]==l_True)?"":"-", i+1);
+            fprintf(res, " 0\n");
+        }else
+            fprintf(res, "UNSAT\n");
+        fclose(res);
+    }
+
+#ifdef NDEBUG
+    exit(ret ? 10 : 20);     // (faster than "return", which will invoke the destructor for 'Solver')
+#endif
+}
diff -ruN src_tmp/minisat/core/Makefile src/minisat/core/Makefile
--- src_tmp/minisat/core/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ src/minisat/core/Makefile	2022-02-19 12:06:50.626500104 +0100
@@ -0,0 +1,7 @@
+MTL       = ../mtl
+CHDRS     = $(wildcard *.h) $(wildcard $(MTL)/*.h)
+EXEC      = qmaxsat
+CFLAGS    = -I$(MTL) -Wall -ffloat-store
+LFLAGS    = -lz
+
+include ../mtl/template.mk
diff -ruN src_tmp/minisat/core/Solver.C src/minisat/core/Solver.C
--- src_tmp/minisat/core/Solver.C	1970-01-01 01:00:00.000000000 +0100
+++ src/minisat/core/Solver.C	2022-02-19 12:06:50.626500104 +0100
@@ -0,0 +1,741 @@
+/****************************************************************************************[Solver.C]
+MiniSat -- Copyright (c) 2003-2006, Niklas Een, Niklas Sorensson
+
+Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
+associated documentation files (the "Software"), to deal in the Software without restriction,
+including without limitation the rights to use, copy, modify, merge, publish, distribute,
+sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all copies or
+substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
+NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT
+OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+**************************************************************************************************/
+
+#include "Solver.h"
+#include "Sort.h"
+#include <cmath>
+
+
+//=================================================================================================
+// Constructor/Destructor:
+
+
+Solver::Solver() :
+
+    // Parameters: (formerly in 'SearchParams')
+    var_decay(1 / 0.95), clause_decay(1 / 0.999), random_var_freq(0.02)
+  , restart_first(100), restart_inc(1.5), learntsize_factor((double)1/(double)3), learntsize_inc(1.1)
+
+    // More parameters:
+    //
+  , expensive_ccmin  (true)
+  , polarity_mode    (polarity_false)
+  , verbosity        (0)
+
+    // Statistics: (formerly in 'SolverStats')
+    //
+  , starts(0), decisions(0), rnd_decisions(0), propagations(0), conflicts(0)
+  , clauses_literals(0), learnts_literals(0), max_literals(0), tot_literals(0)
+
+  , ok               (true)
+  , cla_inc          (1)
+  , var_inc          (1)
+  , qhead            (0)
+  , simpDB_assigns   (-1)
+  , simpDB_props     (0)
+  , order_heap       (VarOrderLt(activity))
+  , random_seed      (91648253)
+  , progress_estimate(0)
+  , remove_satisfied (true)
+{}
+
+
+Solver::~Solver()
+{
+    for (int i = 0; i < learnts.size(); i++) free(learnts[i]);
+    for (int i = 0; i < clauses.size(); i++) free(clauses[i]);
+}
+
+
+//=================================================================================================
+// Minor methods:
+
+
+// Creates a new SAT variable in the solver. If 'decision_var' is cleared, variable will not be
+// used as a decision variable (NOTE! This has effects on the meaning of a SATISFIABLE result).
+//
+Var Solver::newVar(bool sign, bool dvar)
+{
+    int v = nVars();
+    watches   .push();          // (list for positive literal)
+    watches   .push();          // (list for negative literal)
+    reason    .push(NULL);
+    assigns   .push(toInt(l_Undef));
+    level     .push(-1);
+    activity  .push(0);
+    seen      .push(0);
+
+    polarity    .push((char)sign);
+    decision_var.push((char)dvar);
+
+    insertVarOrder(v);
+    return v;
+}
+
+
+bool Solver::addClause(vec<Lit>& ps)
+{
+    assert(decisionLevel() == 0);
+
+    if (!ok)
+        return false;
+    else{
+        // Check if clause is satisfied and remove false/duplicate literals:
+        sort(ps);
+        Lit p; int i, j;
+        for (i = j = 0, p = lit_Undef; i < ps.size(); i++)
+            if (value(ps[i]) == l_True || ps[i] == ~p)
+                return true;
+            else if (value(ps[i]) != l_False && ps[i] != p)
+                ps[j++] = p = ps[i];
+        ps.shrink(i - j);
+    }
+
+    if (ps.size() == 0)
+        return ok = false;
+    else if (ps.size() == 1){
+        assert(value(ps[0]) == l_Undef);
+        uncheckedEnqueue(ps[0]);
+        return ok = (propagate() == NULL);
+    }else{
+        Clause* c = Clause_new(ps, false);
+        clauses.push(c);
+        attachClause(*c);
+    }
+
+    return true;
+}
+
+
+void Solver::attachClause(Clause& c) {
+    assert(c.size() > 1);
+    watches[toInt(~c[0])].push(&c);
+    watches[toInt(~c[1])].push(&c);
+    if (c.learnt()) learnts_literals += c.size();
+    else            clauses_literals += c.size(); }
+
+
+void Solver::detachClause(Clause& c) {
+    assert(c.size() > 1);
+    assert(find(watches[toInt(~c[0])], &c));
+    assert(find(watches[toInt(~c[1])], &c));
+    remove(watches[toInt(~c[0])], &c);
+    remove(watches[toInt(~c[1])], &c);
+    if (c.learnt()) learnts_literals -= c.size();
+    else            clauses_literals -= c.size(); }
+
+
+void Solver::removeClause(Clause& c) {
+    detachClause(c);
+    free(&c); }
+
+
+bool Solver::satisfied(const Clause& c) const {
+    for (int i = 0; i < c.size(); i++)
+        if (value(c[i]) == l_True)
+            return true;
+    return false; }
+
+
+// Revert to the state at given level (keeping all assignment at 'level' but not beyond).
+//
+void Solver::cancelUntil(int level) {
+    if (decisionLevel() > level){
+        for (int c = trail.size()-1; c >= trail_lim[level]; c--){
+            Var     x  = var(trail[c]);
+            assigns[x] = toInt(l_Undef);
+            insertVarOrder(x); }
+        qhead = trail_lim[level];
+        trail.shrink(trail.size() - trail_lim[level]);
+        trail_lim.shrink(trail_lim.size() - level);
+    } }
+
+
+//=================================================================================================
+// Major methods:
+
+
+Lit Solver::pickBranchLit(int polarity_mode, double random_var_freq)
+{
+    Var next = var_Undef;
+
+    // Random decision:
+    if (drand(random_seed) < random_var_freq && !order_heap.empty()){
+        next = order_heap[irand(random_seed,order_heap.size())];
+        if (toLbool(assigns[next]) == l_Undef && decision_var[next])
+            rnd_decisions++; }
+
+    // Activity based decision:
+    while (next == var_Undef || toLbool(assigns[next]) != l_Undef || !decision_var[next])
+        if (order_heap.empty()){
+            next = var_Undef;
+            break;
+        }else
+            next = order_heap.removeMin();
+
+    bool sign = false;
+    switch (polarity_mode){
+    case polarity_true:  sign = false; break;
+    case polarity_false: sign = true;  break;
+    case polarity_user:  sign = polarity[next]; break;
+    case polarity_rnd:   sign = irand(random_seed, 2); break;
+    default: assert(false); }
+
+    return next == var_Undef ? lit_Undef : Lit(next, sign);
+}
+
+
+/*_________________________________________________________________________________________________
+|
+|  analyze : (confl : Clause*) (out_learnt : vec<Lit>&) (out_btlevel : int&)  ->  [void]
+|  
+|  Description:
+|    Analyze conflict and produce a reason clause.
+|  
+|    Pre-conditions:
+|      * 'out_learnt' is assumed to be cleared.
+|      * Current decision level must be greater than root level.
+|  
+|    Post-conditions:
+|      * 'out_learnt[0]' is the asserting literal at level 'out_btlevel'.
+|  
+|  Effect:
+|    Will undo part of the trail, upto but not beyond the assumption of the current decision level.
+|________________________________________________________________________________________________@*/
+void Solver::analyze(Clause* confl, vec<Lit>& out_learnt, int& out_btlevel)
+{
+    int pathC = 0;
+    Lit p     = lit_Undef;
+
+    // Generate conflict clause:
+    //
+    out_learnt.push();      // (leave room for the asserting literal)
+    int index   = trail.size() - 1;
+    out_btlevel = 0;
+
+    do{
+        assert(confl != NULL);          // (otherwise should be UIP)
+        Clause& c = *confl;
+
+        if (c.learnt())
+            claBumpActivity(c);
+
+        for (int j = (p == lit_Undef) ? 0 : 1; j < c.size(); j++){
+            Lit q = c[j];
+
+            if (!seen[var(q)] && level[var(q)] > 0){
+                varBumpActivity(var(q));
+                seen[var(q)] = 1;
+                if (level[var(q)] >= decisionLevel())
+                    pathC++;
+                else{
+                    out_learnt.push(q);
+                    if (level[var(q)] > out_btlevel)
+                        out_btlevel = level[var(q)];
+                }
+            }
+        }
+
+        // Select next clause to look at:
+        while (!seen[var(trail[index--])]);
+        p     = trail[index+1];
+        confl = reason[var(p)];
+        seen[var(p)] = 0;
+        pathC--;
+
+    }while (pathC > 0);
+    out_learnt[0] = ~p;
+
+    // Simplify conflict clause:
+    //
+    int i, j;
+    if (expensive_ccmin){
+        uint32_t abstract_level = 0;
+        for (i = 1; i < out_learnt.size(); i++)
+            abstract_level |= abstractLevel(var(out_learnt[i])); // (maintain an abstraction of levels involved in conflict)
+
+        out_learnt.copyTo(analyze_toclear);
+        for (i = j = 1; i < out_learnt.size(); i++)
+            if (reason[var(out_learnt[i])] == NULL || !litRedundant(out_learnt[i], abstract_level))
+                out_learnt[j++] = out_learnt[i];
+    }else{
+        out_learnt.copyTo(analyze_toclear);
+        for (i = j = 1; i < out_learnt.size(); i++){
+            Clause& c = *reason[var(out_learnt[i])];
+            for (int k = 1; k < c.size(); k++)
+                if (!seen[var(c[k])] && level[var(c[k])] > 0){
+                    out_learnt[j++] = out_learnt[i];
+                    break; }
+        }
+    }
+    max_literals += out_learnt.size();
+    out_learnt.shrink(i - j);
+    tot_literals += out_learnt.size();
+
+    // Find correct backtrack level:
+    //
+    if (out_learnt.size() == 1)
+        out_btlevel = 0;
+    else{
+        int max_i = 1;
+        for (int i = 2; i < out_learnt.size(); i++)
+            if (level[var(out_learnt[i])] > level[var(out_learnt[max_i])])
+                max_i = i;
+        Lit p             = out_learnt[max_i];
+        out_learnt[max_i] = out_learnt[1];
+        out_learnt[1]     = p;
+        out_btlevel       = level[var(p)];
+    }
+
+
+    for (int j = 0; j < analyze_toclear.size(); j++) seen[var(analyze_toclear[j])] = 0;    // ('seen[]' is now cleared)
+}
+
+
+// Check if 'p' can be removed. 'abstract_levels' is used to abort early if the algorithm is
+// visiting literals at levels that cannot be removed later.
+bool Solver::litRedundant(Lit p, uint32_t abstract_levels)
+{
+    analyze_stack.clear(); analyze_stack.push(p);
+    int top = analyze_toclear.size();
+    while (analyze_stack.size() > 0){
+        assert(reason[var(analyze_stack.last())] != NULL);
+        Clause& c = *reason[var(analyze_stack.last())]; analyze_stack.pop();
+
+        for (int i = 1; i < c.size(); i++){
+            Lit p  = c[i];
+            if (!seen[var(p)] && level[var(p)] > 0){
+                if (reason[var(p)] != NULL && (abstractLevel(var(p)) & abstract_levels) != 0){
+                    seen[var(p)] = 1;
+                    analyze_stack.push(p);
+                    analyze_toclear.push(p);
+                }else{
+                    for (int j = top; j < analyze_toclear.size(); j++)
+                        seen[var(analyze_toclear[j])] = 0;
+                    analyze_toclear.shrink(analyze_toclear.size() - top);
+                    return false;
+                }
+            }
+        }
+    }
+
+    return true;
+}
+
+
+/*_________________________________________________________________________________________________
+|
+|  analyzeFinal : (p : Lit)  ->  [void]
+|  
+|  Description:
+|    Specialized analysis procedure to express the final conflict in terms of assumptions.
+|    Calculates the (possibly empty) set of assumptions that led to the assignment of 'p', and
+|    stores the result in 'out_conflict'.
+|________________________________________________________________________________________________@*/
+void Solver::analyzeFinal(Lit p, vec<Lit>& out_conflict)
+{
+    out_conflict.clear();
+    out_conflict.push(p);
+
+    if (decisionLevel() == 0)
+        return;
+
+    seen[var(p)] = 1;
+
+    for (int i = trail.size()-1; i >= trail_lim[0]; i--){
+        Var x = var(trail[i]);
+        if (seen[x]){
+            if (reason[x] == NULL){
+                assert(level[x] > 0);
+                out_conflict.push(~trail[i]);
+            }else{
+                Clause& c = *reason[x];
+                for (int j = 1; j < c.size(); j++)
+                    if (level[var(c[j])] > 0)
+                        seen[var(c[j])] = 1;
+            }
+            seen[x] = 0;
+        }
+    }
+
+    seen[var(p)] = 0;
+}
+
+
+void Solver::uncheckedEnqueue(Lit p, Clause* from)
+{
+    assert(value(p) == l_Undef);
+    assigns [var(p)] = toInt(lbool(!sign(p)));  // <<== abstract but not uttermost effecient
+    level   [var(p)] = decisionLevel();
+    reason  [var(p)] = from;
+    trail.push(p);
+}
+
+
+/*_________________________________________________________________________________________________
+|
+|  propagate : [void]  ->  [Clause*]
+|  
+|  Description:
+|    Propagates all enqueued facts. If a conflict arises, the conflicting clause is returned,
+|    otherwise NULL.
+|  
+|    Post-conditions:
+|      * the propagation queue is empty, even if there was a conflict.
+|________________________________________________________________________________________________@*/
+Clause* Solver::propagate()
+{
+    Clause* confl     = NULL;
+    int     num_props = 0;
+
+    while (qhead < trail.size()){
+        Lit            p   = trail[qhead++];     // 'p' is enqueued fact to propagate.
+        vec<Clause*>&  ws  = watches[toInt(p)];
+        Clause         **i, **j, **end;
+        num_props++;
+
+        for (i = j = (Clause**)ws, end = i + ws.size();  i != end;){
+            Clause& c = **i++;
+
+            // Make sure the false literal is data[1]:
+            Lit false_lit = ~p;
+            if (c[0] == false_lit)
+                c[0] = c[1], c[1] = false_lit;
+
+            assert(c[1] == false_lit);
+
+            // If 0th watch is true, then clause is already satisfied.
+            Lit first = c[0];
+            if (value(first) == l_True){
+                *j++ = &c;
+            }else{
+                // Look for new watch:
+                for (int k = 2; k < c.size(); k++)
+                    if (value(c[k]) != l_False){
+                        c[1] = c[k]; c[k] = false_lit;
+                        watches[toInt(~c[1])].push(&c);
+                        goto FoundWatch; }
+
+                // Did not find watch -- clause is unit under assignment:
+                *j++ = &c;
+                if (value(first) == l_False){
+                    confl = &c;
+                    qhead = trail.size();
+                    // Copy the remaining watches:
+                    while (i < end)
+                        *j++ = *i++;
+                }else
+                    uncheckedEnqueue(first, &c);
+            }
+        FoundWatch:;
+        }
+        ws.shrink(i - j);
+    }
+    propagations += num_props;
+    simpDB_props -= num_props;
+
+    return confl;
+}
+
+/*_________________________________________________________________________________________________
+|
+|  reduceDB : ()  ->  [void]
+|  
+|  Description:
+|    Remove half of the learnt clauses, minus the clauses locked by the current assignment. Locked
+|    clauses are clauses that are reason to some assignment. Binary clauses are never removed.
+|________________________________________________________________________________________________@*/
+struct reduceDB_lt { bool operator () (Clause* x, Clause* y) { return x->size() > 2 && (y->size() == 2 || x->activity() < y->activity()); } };
+void Solver::reduceDB()
+{
+    int     i, j;
+    double  extra_lim = cla_inc / learnts.size();    // Remove any clause below this activity
+
+    sort(learnts, reduceDB_lt());
+    for (i = j = 0; i < learnts.size() / 2; i++){
+        if (learnts[i]->size() > 2 && !locked(*learnts[i]))
+            removeClause(*learnts[i]);
+        else
+            learnts[j++] = learnts[i];
+    }
+    for (; i < learnts.size(); i++){
+        if (learnts[i]->size() > 2 && !locked(*learnts[i]) && learnts[i]->activity() < extra_lim)
+            removeClause(*learnts[i]);
+        else
+            learnts[j++] = learnts[i];
+    }
+    learnts.shrink(i - j);
+}
+
+
+void Solver::removeSatisfied(vec<Clause*>& cs)
+{
+    int i,j;
+    for (i = j = 0; i < cs.size(); i++){
+        if (satisfied(*cs[i]))
+            removeClause(*cs[i]);
+        else
+            cs[j++] = cs[i];
+    }
+    cs.shrink(i - j);
+}
+
+
+/*_________________________________________________________________________________________________
+|
+|  simplify : [void]  ->  [bool]
+|  
+|  Description:
+|    Simplify the clause database according to the current top-level assigment. Currently, the only
+|    thing done here is the removal of satisfied clauses, but more things can be put here.
+|________________________________________________________________________________________________@*/
+bool Solver::simplify()
+{
+    assert(decisionLevel() == 0);
+
+    if (!ok || propagate() != NULL)
+        return ok = false;
+
+    if (nAssigns() == simpDB_assigns || (simpDB_props > 0))
+        return true;
+
+    // Remove satisfied clauses:
+    removeSatisfied(learnts);
+    if (remove_satisfied)        // Can be turned off.
+        removeSatisfied(clauses);
+
+    // Remove fixed variables from the variable heap:
+    order_heap.filter(VarFilter(*this));
+
+    simpDB_assigns = nAssigns();
+    simpDB_props   = clauses_literals + learnts_literals;   // (shouldn't depend on stats really, but it will do for now)
+
+    return true;
+}
+
+
+/*_________________________________________________________________________________________________
+|
+|  search : (nof_conflicts : int) (nof_learnts : int) (params : const SearchParams&)  ->  [lbool]
+|  
+|  Description:
+|    Search for a model the specified number of conflicts, keeping the number of learnt clauses
+|    below the provided limit. NOTE! Use negative value for 'nof_conflicts' or 'nof_learnts' to
+|    indicate infinity.
+|  
+|  Output:
+|    'l_True' if a partial assigment that is consistent with respect to the clauseset is found. If
+|    all variables are decision variables, this means that the clause set is satisfiable. 'l_False'
+|    if the clause set is unsatisfiable. 'l_Undef' if the bound on number of conflicts is reached.
+|________________________________________________________________________________________________@*/
+lbool Solver::search(int nof_conflicts, int nof_learnts)
+{
+    assert(ok);
+    int         backtrack_level;
+    int         conflictC = 0;
+    vec<Lit>    learnt_clause;
+
+    starts++;
+
+    bool first = true;
+
+    for (;;){
+        Clause* confl = propagate();
+        if (confl != NULL){
+            // CONFLICT
+            conflicts++; conflictC++;
+            if (decisionLevel() == 0) return l_False;
+
+            first = false;
+
+            learnt_clause.clear();
+            analyze(confl, learnt_clause, backtrack_level);
+            cancelUntil(backtrack_level);
+            assert(value(learnt_clause[0]) == l_Undef);
+
+            if (learnt_clause.size() == 1){
+                uncheckedEnqueue(learnt_clause[0]);
+            }else{
+                Clause* c = Clause_new(learnt_clause, true);
+                learnts.push(c);
+                attachClause(*c);
+                claBumpActivity(*c);
+                uncheckedEnqueue(learnt_clause[0], c);
+            }
+
+            varDecayActivity();
+            claDecayActivity();
+
+        }else{
+            // NO CONFLICT
+
+            if (nof_conflicts >= 0 && conflictC >= nof_conflicts){
+                // Reached bound on number of conflicts:
+                progress_estimate = progressEstimate();
+                cancelUntil(0);
+                return l_Undef; }
+
+            // Simplify the set of problem clauses:
+            if (decisionLevel() == 0 && !simplify())
+                return l_False;
+
+            if (nof_learnts >= 0 && learnts.size()-nAssigns() >= nof_learnts)
+                // Reduce the set of learnt clauses:
+                reduceDB();
+
+            Lit next = lit_Undef;
+            while (decisionLevel() < assumptions.size()){
+                // Perform user provided assumption:
+                Lit p = assumptions[decisionLevel()];
+                if (value(p) == l_True){
+                    // Dummy decision level:
+                    newDecisionLevel();
+                }else if (value(p) == l_False){
+                    analyzeFinal(~p, conflict);
+                    return l_False;
+                }else{
+                    next = p;
+                    break;
+                }
+            }
+
+            if (next == lit_Undef){
+                // New variable decision:
+                decisions++;
+                next = pickBranchLit(polarity_mode, random_var_freq);
+
+                if (next == lit_Undef)
+                    // Model found:
+                    return l_True;
+            }
+
+            // Increase decision level and enqueue 'next'
+            assert(value(next) == l_Undef);
+            newDecisionLevel();
+            uncheckedEnqueue(next);
+        }
+    }
+}
+
+
+double Solver::progressEstimate() const
+{
+    double  progress = 0;
+    double  F = 1.0 / nVars();
+
+    for (int i = 0; i <= decisionLevel(); i++){
+        int beg = i == 0 ? 0 : trail_lim[i - 1];
+        int end = i == decisionLevel() ? trail.size() : trail_lim[i];
+        progress += pow(F, i) * (end - beg);
+    }
+
+    return progress / nVars();
+}
+
+
+bool Solver::solve(const vec<Lit>& assumps)
+{
+    model.clear();
+    conflict.clear();
+
+    if (!ok) return false;
+
+    assumps.copyTo(assumptions);
+
+    double  nof_conflicts = restart_first;
+    double  nof_learnts   = nClauses() * learntsize_factor;
+    lbool   status        = l_Undef;
+
+    if (verbosity >= 1){
+        reportf("============================[ Search Statistics ]==============================\n");
+        reportf("| Conflicts |          ORIGINAL         |          LEARNT          | Progress |\n");
+        reportf("|           |    Vars  Clauses Literals |    Limit  Clauses Lit/Cl |          |\n");
+        reportf("===============================================================================\n");
+    }
+
+    // Search:
+    while (status == l_Undef){
+        if (verbosity >= 1)
+            reportf("| %9d | %7d %8d %8d | %8d %8d %6.0f | %6.3f %% |\n", (int)conflicts, order_heap.size(), nClauses(), (int)clauses_literals, (int)nof_learnts, nLearnts(), (double)learnts_literals/nLearnts(), progress_estimate*100), fflush(stdout);
+        status = search((int)nof_conflicts, (int)nof_learnts);
+        nof_conflicts *= restart_inc;
+        nof_learnts   *= learntsize_inc;
+    }
+
+    if (verbosity >= 1)
+        reportf("===============================================================================\n");
+
+
+    if (status == l_True){
+        // Extend & copy model:
+        model.growTo(nVars());
+        for (int i = 0; i < nVars(); i++) model[i] = value(i);
+#ifndef NDEBUG
+        verifyModel();
+#endif
+    }else{
+        assert(status == l_False);
+        if (conflict.size() == 0)
+            ok = false;
+    }
+
+    cancelUntil(0);
+    return status == l_True;
+}
+
+//=================================================================================================
+// Debug methods:
+
+
+void Solver::verifyModel()
+{
+    bool failed = false;
+    for (int i = 0; i < clauses.size(); i++){
+        assert(clauses[i]->mark() == 0);
+        Clause& c = *clauses[i];
+        for (int j = 0; j < c.size(); j++)
+            if (modelValue(c[j]) == l_True)
+                goto next;
+
+        reportf("unsatisfied clause: ");
+        printClause(*clauses[i]);
+        reportf("\n");
+        failed = true;
+    next:;
+    }
+
+    assert(!failed);
+
+    reportf("Verified %d original clauses.\n", clauses.size());
+}
+
+
+void Solver::checkLiteralCount()
+{
+    // Check that sizes are calculated correctly:
+    int cnt = 0;
+    for (int i = 0; i < clauses.size(); i++)
+        if (clauses[i]->mark() == 0)
+            cnt += clauses[i]->size();
+
+    if ((int)clauses_literals != cnt){
+        fprintf(stderr, "literal count: %d, real value = %d\n", (int)clauses_literals, cnt);
+        assert((int)clauses_literals == cnt);
+    }
+}
diff -ruN src_tmp/minisat/core/Solver.h src/minisat/core/Solver.h
--- src_tmp/minisat/core/Solver.h	1970-01-01 01:00:00.000000000 +0100
+++ src/minisat/core/Solver.h	2022-02-19 12:06:50.626500104 +0100
@@ -0,0 +1,302 @@
+/****************************************************************************************[Solver.h]
+MiniSat -- Copyright (c) 2003-2006, Niklas Een, Niklas Sorensson
+
+Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
+associated documentation files (the "Software"), to deal in the Software without restriction,
+including without limitation the rights to use, copy, modify, merge, publish, distribute,
+sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all copies or
+substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
+NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT
+OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+**************************************************************************************************/
+
+#ifndef Solver_h
+#define Solver_h
+
+#include <cstdio>
+
+#include "Vec.h"
+#include "Heap.h"
+#include "Alg.h"
+
+#include "SolverTypes.h"
+
+
+//=================================================================================================
+// Solver -- the main class:
+
+
+class Solver {
+public:
+
+    // Constructor/Destructor:
+    //
+    Solver();
+    ~Solver();
+
+    // Problem specification:
+    //
+    Var     newVar    (bool polarity = true, bool dvar = true); // Add a new variable with parameters specifying variable mode.
+    bool    addClause (vec<Lit>& ps);                           // Add a clause to the solver. NOTE! 'ps' may be shrunk by this method!
+
+    // Solving:
+    //
+    bool    simplify     ();                        // Removes already satisfied clauses.
+    bool    solve        (const vec<Lit>& assumps); // Search for a model that respects a given set of assumptions.
+    bool    solve        ();                        // Search without assumptions.
+    bool    okay         () const;                  // FALSE means solver is in a conflicting state
+
+    // Variable mode:
+    // 
+    void    setPolarity    (Var v, bool b); // Declare which polarity the decision heuristic should use for a variable. Requires mode 'polarity_user'.
+    void    setDecisionVar (Var v, bool b); // Declare if a variable should be eligible for selection in the decision heuristic.
+
+    // Read state:
+    //
+    lbool   value      (Var x) const;       // The current value of a variable.
+    lbool   value      (Lit p) const;       // The current value of a literal.
+    lbool   modelValue (Lit p) const;       // The value of a literal in the last model. The last call to solve must have been satisfiable.
+    int     nAssigns   ()      const;       // The current number of assigned literals.
+    int     nClauses   ()      const;       // The current number of original clauses.
+    int     nLearnts   ()      const;       // The current number of learnt clauses.
+    int     nVars      ()      const;       // The current number of variables.
+
+    // Extra results: (read-only member variable)
+    //
+    vec<lbool> model;             // If problem is satisfiable, this vector contains the model (if any).
+    vec<Lit>   conflict;          // If problem is unsatisfiable (possibly under assumptions),
+                                  // this vector represent the final conflict clause expressed in the assumptions.
+
+    // Mode of operation:
+    //
+    double    var_decay;          // Inverse of the variable activity decay factor.                                            (default 1 / 0.95)
+    double    clause_decay;       // Inverse of the clause activity decay factor.                                              (1 / 0.999)
+    double    random_var_freq;    // The frequency with which the decision heuristic tries to choose a random variable.        (default 0.02)
+    int       restart_first;      // The initial restart limit.                                                                (default 100)
+    double    restart_inc;        // The factor with which the restart limit is multiplied in each restart.                    (default 1.5)
+    double    learntsize_factor;  // The intitial limit for learnt clauses is a factor of the original clauses.                (default 1 / 3)
+    double    learntsize_inc;     // The limit for learnt clauses is multiplied with this factor each restart.                 (default 1.1)
+    bool      expensive_ccmin;    // Controls conflict clause minimization.                                                    (default TRUE)
+    int       polarity_mode;      // Controls which polarity the decision heuristic chooses. See enum below for allowed modes. (default polarity_false)
+    int       verbosity;          // Verbosity level. 0=silent, 1=some progress report                                         (default 0)
+
+    enum { polarity_true = 0, polarity_false = 1, polarity_user = 2, polarity_rnd = 3 };
+
+    // Statistics: (read-only member variable)
+    //
+    uint64_t starts, decisions, rnd_decisions, propagations, conflicts;
+    uint64_t clauses_literals, learnts_literals, max_literals, tot_literals;
+
+protected:
+
+    // Helper structures:
+    //
+    struct VarOrderLt {
+        const vec<double>&  activity;
+        bool operator () (Var x, Var y) const { return activity[x] > activity[y]; }
+        VarOrderLt(const vec<double>&  act) : activity(act) { }
+    };
+
+    friend class VarFilter;
+    struct VarFilter {
+        const Solver& s;
+        VarFilter(const Solver& _s) : s(_s) {}
+        bool operator()(Var v) const { return toLbool(s.assigns[v]) == l_Undef && s.decision_var[v]; }
+    };
+
+    // Solver state:
+    //
+    bool                ok;               // If FALSE, the constraints are already unsatisfiable. No part of the solver state may be used!
+    vec<Clause*>        clauses;          // List of problem clauses.
+    vec<Clause*>        learnts;          // List of learnt clauses.
+    double              cla_inc;          // Amount to bump next clause with.
+    vec<double>         activity;         // A heuristic measurement of the activity of a variable.
+    double              var_inc;          // Amount to bump next variable with.
+    vec<vec<Clause*> >  watches;          // 'watches[lit]' is a list of constraints watching 'lit' (will go there if literal becomes true).
+    vec<char>           assigns;          // The current assignments (lbool:s stored as char:s).
+    vec<char>           polarity;         // The preferred polarity of each variable.
+    vec<char>           decision_var;     // Declares if a variable is eligible for selection in the decision heuristic.
+    vec<Lit>            trail;            // Assignment stack; stores all assigments made in the order they were made.
+    vec<int>            trail_lim;        // Separator indices for different decision levels in 'trail'.
+    vec<Clause*>        reason;           // 'reason[var]' is the clause that implied the variables current value, or 'NULL' if none.
+    vec<int>            level;            // 'level[var]' contains the level at which the assignment was made.
+    int                 qhead;            // Head of queue (as index into the trail -- no more explicit propagation queue in MiniSat).
+    int                 simpDB_assigns;   // Number of top-level assignments since last execution of 'simplify()'.
+    int64_t             simpDB_props;     // Remaining number of propagations that must be made before next execution of 'simplify()'.
+    vec<Lit>            assumptions;      // Current set of assumptions provided to solve by the user.
+    Heap<VarOrderLt>    order_heap;       // A priority queue of variables ordered with respect to the variable activity.
+    double              random_seed;      // Used by the random variable selection.
+    double              progress_estimate;// Set by 'search()'.
+    bool                remove_satisfied; // Indicates whether possibly inefficient linear scan for satisfied clauses should be performed in 'simplify'.
+
+    // Temporaries (to reduce allocation overhead). Each variable is prefixed by the method in which it is
+    // used, exept 'seen' wich is used in several places.
+    //
+    vec<char>           seen;
+    vec<Lit>            analyze_stack;
+    vec<Lit>            analyze_toclear;
+    vec<Lit>            add_tmp;
+
+    // Main internal methods:
+    //
+    void     insertVarOrder   (Var x);                                                 // Insert a variable in the decision order priority queue.
+    Lit      pickBranchLit    (int polarity_mode, double random_var_freq);             // Return the next decision variable.
+    void     newDecisionLevel ();                                                      // Begins a new decision level.
+    void     uncheckedEnqueue (Lit p, Clause* from = NULL);                            // Enqueue a literal. Assumes value of literal is undefined.
+    bool     enqueue          (Lit p, Clause* from = NULL);                            // Test if fact 'p' contradicts current state, enqueue otherwise.
+    Clause*  propagate        ();                                                      // Perform unit propagation. Returns possibly conflicting clause.
+    void     cancelUntil      (int level);                                             // Backtrack until a certain level.
+    void     analyze          (Clause* confl, vec<Lit>& out_learnt, int& out_btlevel); // (bt = backtrack)
+    void     analyzeFinal     (Lit p, vec<Lit>& out_conflict);                         // COULD THIS BE IMPLEMENTED BY THE ORDINARIY "analyze" BY SOME REASONABLE GENERALIZATION?
+    bool     litRedundant     (Lit p, uint32_t abstract_levels);                       // (helper method for 'analyze()')
+    lbool    search           (int nof_conflicts, int nof_learnts);                    // Search for a given number of conflicts.
+    void     reduceDB         ();                                                      // Reduce the set of learnt clauses.
+    void     removeSatisfied  (vec<Clause*>& cs);                                      // Shrink 'cs' to contain only non-satisfied clauses.
+
+    // Maintaining Variable/Clause activity:
+    //
+    void     varDecayActivity ();                      // Decay all variables with the specified factor. Implemented by increasing the 'bump' value instead.
+    void     varBumpActivity  (Var v);                 // Increase a variable with the current 'bump' value.
+    void     claDecayActivity ();                      // Decay all clauses with the specified factor. Implemented by increasing the 'bump' value instead.
+    void     claBumpActivity  (Clause& c);             // Increase a clause with the current 'bump' value.
+
+    // Operations on clauses:
+    //
+    void     attachClause     (Clause& c);             // Attach a clause to watcher lists.
+    void     detachClause     (Clause& c);             // Detach a clause to watcher lists.
+    void     removeClause     (Clause& c);             // Detach and free a clause.
+    bool     locked           (const Clause& c) const; // Returns TRUE if a clause is a reason for some implication in the current state.
+    bool     satisfied        (const Clause& c) const; // Returns TRUE if a clause is satisfied in the current state.
+
+    // Misc:
+    //
+    int      decisionLevel    ()      const; // Gives the current decisionlevel.
+    uint32_t abstractLevel    (Var x) const; // Used to represent an abstraction of sets of decision levels.
+    double   progressEstimate ()      const; // DELETE THIS ?? IT'S NOT VERY USEFUL ...
+
+    // Debug:
+    void     printLit         (Lit l);
+    template<class C>
+    void     printClause      (const C& c);
+    void     verifyModel      ();
+    void     checkLiteralCount();
+
+    // Static helpers:
+    //
+
+    // Returns a random float 0 <= x < 1. Seed must never be 0.
+    static inline double drand(double& seed) {
+        seed *= 1389796;
+        int q = (int)(seed / 2147483647);
+        seed -= (double)q * 2147483647;
+        return seed / 2147483647; }
+
+    // Returns a random integer 0 <= x < size. Seed must never be 0.
+    static inline int irand(double& seed, int size) {
+        return (int)(drand(seed) * size); }
+};
+
+
+//=================================================================================================
+// Implementation of inline methods:
+
+
+inline void Solver::insertVarOrder(Var x) {
+    if (!order_heap.inHeap(x) && decision_var[x]) order_heap.insert(x); }
+
+inline void Solver::varDecayActivity() { var_inc *= var_decay; }
+inline void Solver::varBumpActivity(Var v) {
+    if ( (activity[v] += var_inc) > 1e100 ) {
+        // Rescale:
+        for (int i = 0; i < nVars(); i++)
+            activity[i] *= 1e-100;
+        var_inc *= 1e-100; }
+
+    // Update order_heap with respect to new activity:
+    if (order_heap.inHeap(v))
+        order_heap.decrease(v); }
+
+inline void Solver::claDecayActivity() { cla_inc *= clause_decay; }
+inline void Solver::claBumpActivity (Clause& c) {
+        if ( (c.activity() += cla_inc) > 1e20 ) {
+            // Rescale:
+            for (int i = 0; i < learnts.size(); i++)
+                learnts[i]->activity() *= 1e-20;
+            cla_inc *= 1e-20; } }
+
+inline bool     Solver::enqueue         (Lit p, Clause* from)   { return value(p) != l_Undef ? value(p) != l_False : (uncheckedEnqueue(p, from), true); }
+inline bool     Solver::locked          (const Clause& c) const { return reason[var(c[0])] == &c && value(c[0]) == l_True; }
+inline void     Solver::newDecisionLevel()                      { trail_lim.push(trail.size()); }
+
+inline int      Solver::decisionLevel ()      const   { return trail_lim.size(); }
+inline uint32_t Solver::abstractLevel (Var x) const   { return 1 << (level[x] & 31); }
+inline lbool    Solver::value         (Var x) const   { return toLbool(assigns[x]); }
+inline lbool    Solver::value         (Lit p) const   { return toLbool(assigns[var(p)]) ^ sign(p); }
+inline lbool    Solver::modelValue    (Lit p) const   { return model[var(p)] ^ sign(p); }
+inline int      Solver::nAssigns      ()      const   { return trail.size(); }
+inline int      Solver::nClauses      ()      const   { return clauses.size(); }
+inline int      Solver::nLearnts      ()      const   { return learnts.size(); }
+inline int      Solver::nVars         ()      const   { return assigns.size(); }
+inline void     Solver::setPolarity   (Var v, bool b) { polarity    [v] = (char)b; }
+inline void     Solver::setDecisionVar(Var v, bool b) { decision_var[v] = (char)b; if (b) { insertVarOrder(v); } }
+inline bool     Solver::solve         ()              { vec<Lit> tmp; return solve(tmp); }
+inline bool     Solver::okay          ()      const   { return ok; }
+
+
+
+//=================================================================================================
+// Debug + etc:
+
+
+#define reportf(format, args...) ( fflush(stdout), fprintf(stderr, format, ## args), fflush(stderr) )
+
+static inline void logLit(FILE* f, Lit l)
+{
+    fprintf(f, "%sx%d", sign(l) ? "~" : "", var(l)+1);
+}
+
+static inline void logLits(FILE* f, const vec<Lit>& ls)
+{
+    fprintf(f, "[ ");
+    if (ls.size() > 0){
+        logLit(f, ls[0]);
+        for (int i = 1; i < ls.size(); i++){
+            fprintf(f, ", ");
+            logLit(f, ls[i]);
+        }
+    }
+    fprintf(f, "] ");
+}
+
+static inline const char* showBool(bool b) { return b ? "true" : "false"; }
+
+
+// Just like 'assert()' but expression will be evaluated in the release version as well.
+static inline void check(bool expr) { assert(expr); }
+
+
+inline void Solver::printLit(Lit l)
+{
+    reportf("%s%d:%c", sign(l) ? "-" : "", var(l)+1, value(l) == l_True ? '1' : (value(l) == l_False ? '0' : 'X'));
+}
+
+
+template<class C>
+inline void Solver::printClause(const C& c)
+{
+    for (int i = 0; i < c.size(); i++){
+        printLit(c[i]);
+        fprintf(stderr, " ");
+    }
+}
+
+
+//=================================================================================================
+#endif
diff -ruN src_tmp/minisat/core/SolverTypes.h src/minisat/core/SolverTypes.h
--- src_tmp/minisat/core/SolverTypes.h	1970-01-01 01:00:00.000000000 +0100
+++ src/minisat/core/SolverTypes.h	2022-02-19 12:06:50.626500104 +0100
@@ -0,0 +1,200 @@
+/***********************************************************************************[SolverTypes.h]
+MiniSat -- Copyright (c) 2003-2006, Niklas Een, Niklas Sorensson
+
+Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
+associated documentation files (the "Software"), to deal in the Software without restriction,
+including without limitation the rights to use, copy, modify, merge, publish, distribute,
+sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all copies or
+substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
+NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT
+OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+**************************************************************************************************/
+
+
+#ifndef SolverTypes_h
+#define SolverTypes_h
+
+#include <cassert>
+#include <stdint.h>
+
+//=================================================================================================
+// Variables, literals, lifted booleans, clauses:
+
+
+// NOTE! Variables are just integers. No abstraction here. They should be chosen from 0..N,
+// so that they can be used as array indices.
+
+typedef int Var;
+#define var_Undef (-1)
+
+
+class Lit {
+    int     x;
+ public:
+    Lit() : x(2*var_Undef)                                              { }   // (lit_Undef)
+    explicit Lit(Var var, bool sign = false) : x((var+var) + (int)sign) { }
+
+    // Don't use these for constructing/deconstructing literals. Use the normal constructors instead.
+    friend int  toInt       (Lit p);  // Guarantees small, positive integers suitable for array indexing.
+    friend Lit  toLit       (int i);  // Inverse of 'toInt()'
+    friend Lit  operator   ~(Lit p);
+    friend bool sign        (Lit p);
+    friend int  var         (Lit p);
+    friend Lit  unsign      (Lit p);
+    friend Lit  id          (Lit p, bool sgn);
+
+    bool operator == (Lit p) const { return x == p.x; }
+    bool operator != (Lit p) const { return x != p.x; }
+    bool operator <  (Lit p) const { return x < p.x;  } // '<' guarantees that p, ~p are adjacent in the ordering.
+};
+
+inline  int  toInt       (Lit p)           { return p.x; }
+inline  Lit  toLit       (int i)           { Lit p; p.x = i; return p; }
+inline  Lit  operator   ~(Lit p)           { Lit q; q.x = p.x ^ 1; return q; }
+inline  bool sign        (Lit p)           { return p.x & 1; }
+inline  int  var         (Lit p)           { return p.x >> 1; }
+inline  Lit  unsign      (Lit p)           { Lit q; q.x = p.x & ~1; return q; }
+inline  Lit  id          (Lit p, bool sgn) { Lit q; q.x = p.x ^ (int)sgn; return q; }
+
+const Lit lit_Undef(var_Undef, false);  // }- Useful special constants.
+const Lit lit_Error(var_Undef, true );  // }
+
+
+//=================================================================================================
+// Lifted booleans:
+
+
+class lbool {
+    char     value;
+    explicit lbool(int v) : value(v) { }
+
+public:
+    lbool()       : value(0) { }
+    lbool(bool x) : value((int)x*2-1) { }
+    int toInt(void) const { return value; }
+
+    bool  operator == (lbool b) const { return value == b.value; }
+    bool  operator != (lbool b) const { return value != b.value; }
+    lbool operator ^ (bool b) const { return b ? lbool(-value) : lbool(value); }
+
+    friend int   toInt  (lbool l);
+    friend lbool toLbool(int   v);
+};
+inline int   toInt  (lbool l) { return l.toInt(); }
+inline lbool toLbool(int   v) { return lbool(v);  }
+
+const lbool l_True  = toLbool( 1);
+const lbool l_False = toLbool(-1);
+const lbool l_Undef = toLbool( 0);
+
+//=================================================================================================
+// Clause -- a simple class for representing a clause:
+
+
+class Clause {
+    uint32_t size_etc;
+    union { float act; uint32_t abst; } extra;
+    Lit     data[0];
+
+public:
+    void calcAbstraction() {
+        uint32_t abstraction = 0;
+        for (int i = 0; i < size(); i++)
+            abstraction |= 1 << (var(data[i]) & 31);
+        extra.abst = abstraction;  }
+
+    // NOTE: This constructor cannot be used directly (doesn't allocate enough memory).
+    template<class V>
+    Clause(const V& ps, bool learnt) {
+        size_etc = (ps.size() << 3) | (uint32_t)learnt;
+        for (int i = 0; i < ps.size(); i++) data[i] = ps[i];
+        if (learnt) extra.act = 0; else calcAbstraction(); }
+
+    // -- use this function instead:
+    template<class V>
+    friend Clause* Clause_new(const V& ps, bool learnt); 
+
+    int          size        ()      const   { return size_etc >> 3; }
+    void         shrink      (int i)         { assert(i <= size()); size_etc = (((size_etc >> 3) - i) << 3) | (size_etc & 7); }
+    void         pop         ()              { shrink(1); }
+    bool         learnt      ()      const   { return size_etc & 1; }
+    uint32_t     mark        ()      const   { return (size_etc >> 1) & 3; }
+    void         mark        (uint32_t m)    { size_etc = (size_etc & ~6) | ((m & 3) << 1); }
+    const Lit&   last        ()      const   { return data[size()-1]; }
+
+    // NOTE: somewhat unsafe to change the clause in-place! Must manually call 'calcAbstraction' afterwards for
+    //       subsumption operations to behave correctly.
+    Lit&         operator [] (int i)         { return data[i]; }
+    Lit          operator [] (int i) const   { return data[i]; }
+    operator const Lit* (void) const         { return data; }
+
+    float&       activity    ()              { return extra.act; }
+    uint32_t     abstraction () const { return extra.abst; }
+
+    Lit          subsumes    (const Clause& other) const;
+    void         strengthen  (Lit p);
+};
+
+
+/*_________________________________________________________________________________________________
+|
+|  subsumes : (other : const Clause&)  ->  Lit
+|  
+|  Description:
+|       Checks if clause subsumes 'other', and at the same time, if it can be used to simplify 'other'
+|       by subsumption resolution.
+|  
+|    Result:
+|       lit_Error  - No subsumption or simplification
+|       lit_Undef  - Clause subsumes 'other'
+|       p          - The literal p can be deleted from 'other'
+|________________________________________________________________________________________________@*/
+inline Lit Clause::subsumes(const Clause& other) const
+{
+    if (other.size() < size() || (extra.abst & ~other.extra.abst) != 0)
+        return lit_Error;
+
+    Lit        ret = lit_Undef;
+    const Lit* c  = (const Lit*)(*this);
+    const Lit* d  = (const Lit*)other;
+
+    for (int i = 0; i < size(); i++) {
+        // search for c[i] or ~c[i]
+        for (int j = 0; j < other.size(); j++)
+            if (c[i] == d[j])
+                goto ok;
+            else if (ret == lit_Undef && c[i] == ~d[j]){
+                ret = c[i];
+                goto ok;
+            }
+
+        // did not find it
+        return lit_Error;
+    ok:;
+    }
+
+    return ret;
+}
+
+
+inline void Clause::strengthen(Lit p)
+{
+    remove(*this, p);
+    calcAbstraction();
+}
+
+template<class V>
+inline Clause* Clause_new(const V& ps, bool learnt) {
+    assert(sizeof(Lit)      == sizeof(uint32_t));
+    assert(sizeof(float)    == sizeof(uint32_t));
+    void* mem = malloc(sizeof(Clause) + sizeof(uint32_t)*(ps.size()));
+    return new (mem) Clause(ps, learnt); }
+
+#endif
diff -ruN src_tmp/minisat/doc/ReleaseNotes-2.2.0.txt src/minisat/doc/ReleaseNotes-2.2.0.txt
--- src_tmp/minisat/doc/ReleaseNotes-2.2.0.txt	1970-01-01 01:00:00.000000000 +0100
+++ src/minisat/doc/ReleaseNotes-2.2.0.txt	2022-02-19 12:06:50.626500104 +0100
@@ -0,0 +1,79 @@
+Release Notes for MiniSat 2.2.0
+===============================
+
+Changes since version 2.0:
+
+ * Started using a more standard release numbering.
+
+ * Includes some now well-known heuristics: phase-saving and luby
+   restarts. The old heuristics are still present and can be activated
+   if needed.
+
+ * Detection/Handling of out-of-memory and vector capacity
+   overflow. This is fairly new and relatively untested.
+
+ * Simple resource controls: CPU-time, memory, number of
+   conflicts/decisions.
+
+ * CPU-time limiting is implemented by a more general, but simple,
+   asynchronous interruption feature. This means that the solving
+   procedure can be interrupted from another thread or in a signal
+   handler.
+
+ * Improved portability with respect to building on Solaris and with
+   Visual Studio. This is not regularly tested and chances are that
+   this have been broken since, but should be fairly easy to fix if
+   so.
+
+ * Changed C++ file-extention to the less problematic ".cc".
+
+ * Source code is now namespace-protected
+
+ * Introducing a new Clause Memory Allocator that brings reduced
+   memory consumption on 64-bit architechtures and improved
+   performance (to some extent). The allocator uses a region-based
+   approach were all references to clauses are represented as a 32-bit
+   index into a global memory region that contains all clauses. To
+   free up and compact memory it uses a simple copying garbage
+   collector.
+
+ * Improved unit-propagation by Blocking Literals. For each entry in
+   the watcher lists, pair the pointer to a clause with some
+   (arbitrary) literal from the clause. The idea is that if the
+   literal is currently true (i.e. the clause is satisfied) the
+   watchers of the clause does not need to be altered. This can thus
+   be detected without touching the clause's memory at all. As often
+   as can be done cheaply, the blocking literal for entries to the
+   watcher list of a literal 'p' is set to the other literal watched
+   in the corresponding clause.
+
+ * Basic command-line/option handling system. Makes it easy to specify
+   options in the class that they affect, and whenever that class is
+   used in an executable, parsing of options and help messages are
+   brought in automatically.
+
+ * General clean-up and various minor bug-fixes.
+
+ * Changed implementation of variable-elimination/model-extension:
+    
+     - The interface is changed so that arbitrary remembering is no longer
+       possible. If you need to mention some variable again in the future,
+       this variable has to be frozen.
+    
+     - When eliminating a variable, only clauses that contain the variable
+       with one sign is necessary to store. Thereby making the other sign
+       a "default" value when extending models.
+    
+     - The memory consumption for eliminated clauses is further improved
+       by storing all eliminated clauses in a single contiguous vector.
+
+  * Some common utility code (I/O, Parsing, CPU-time, etc) is ripped
+    out and placed in a separate "utils" directory.
+
+  * The DIMACS parse is refactored so that it can be reused in other
+    applications (not very elegant, but at least possible).
+
+  * Some simple improvements to scalability of preprocessing, using
+    more lazy clause removal from data-structures and a couple of
+    ad-hoc limits (the longest clause that can be produced in variable
+    elimination, and the longest clause used in backward subsumption).
diff -ruN src_tmp/minisat/LICENSE src/minisat/LICENSE
--- src_tmp/minisat/LICENSE	1970-01-01 01:00:00.000000000 +0100
+++ src/minisat/LICENSE	2022-02-19 12:06:50.626500104 +0100
@@ -0,0 +1,21 @@
+MiniSat -- Copyright (c) 2003-2006, Niklas Een, Niklas Sorensson
+           Copyright (c) 2007-2010  Niklas Sorensson
+
+Permission is hereby granted, free of charge, to any person obtaining a
+copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be included
+in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
diff -ruN src_tmp/minisat/mtl/Alg.h src/minisat/mtl/Alg.h
--- src_tmp/minisat/mtl/Alg.h	1970-01-01 01:00:00.000000000 +0100
+++ src/minisat/mtl/Alg.h	2022-02-19 12:06:50.626500104 +0100
@@ -0,0 +1,57 @@
+/*******************************************************************************************[Alg.h]
+MiniSat -- Copyright (c) 2003-2006, Niklas Een, Niklas Sorensson
+
+Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
+associated documentation files (the "Software"), to deal in the Software without restriction,
+including without limitation the rights to use, copy, modify, merge, publish, distribute,
+sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all copies or
+substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
+NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT
+OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+**************************************************************************************************/
+
+#ifndef Alg_h
+#define Alg_h
+
+//=================================================================================================
+// Useful functions on vectors
+
+
+#if 1
+template<class V, class T>
+static inline void remove(V& ts, const T& t)
+{
+    int j = 0;
+    for (; j < ts.size() && ts[j] != t; j++);
+    assert(j < ts.size());
+    for (; j < ts.size()-1; j++) ts[j] = ts[j+1];
+    ts.pop();
+}
+#else
+template<class V, class T>
+static inline void remove(V& ts, const T& t)
+{
+    int j = 0;
+    for (; j < ts.size() && ts[j] != t; j++);
+    assert(j < ts.size());
+    ts[j] = ts.last();
+    ts.pop();
+}
+#endif
+
+template<class V, class T>
+static inline bool find(V& ts, const T& t)
+{
+    int j = 0;
+    for (; j < ts.size() && ts[j] != t; j++);
+    return j < ts.size();
+}
+
+#endif
diff -ruN src_tmp/minisat/mtl/Alloc.h src/minisat/mtl/Alloc.h
--- src_tmp/minisat/mtl/Alloc.h	1970-01-01 01:00:00.000000000 +0100
+++ src/minisat/mtl/Alloc.h	2022-02-19 12:06:50.626500104 +0100
@@ -0,0 +1,131 @@
+/*****************************************************************************************[Alloc.h]
+Copyright (c) 2008-2010, Niklas Sorensson
+
+Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
+associated documentation files (the "Software"), to deal in the Software without restriction,
+including without limitation the rights to use, copy, modify, merge, publish, distribute,
+sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all copies or
+substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
+NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT
+OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+**************************************************************************************************/
+
+
+#ifndef Minisat_Alloc_h
+#define Minisat_Alloc_h
+
+#include "mtl/XAlloc.h"
+#include "mtl/Vec.h"
+
+namespace Minisat {
+
+//=================================================================================================
+// Simple Region-based memory allocator:
+
+template<class T>
+class RegionAllocator
+{
+    T*        memory;
+    uint32_t  sz;
+    uint32_t  cap;
+    uint32_t  wasted_;
+
+    void capacity(uint32_t min_cap);
+
+ public:
+    // TODO: make this a class for better type-checking?
+    typedef uint32_t Ref;
+    enum { Ref_Undef = UINT32_MAX };
+    enum { Unit_Size = sizeof(uint32_t) };
+
+    explicit RegionAllocator(uint32_t start_cap = 1024*1024) : memory(NULL), sz(0), cap(0), wasted_(0){ capacity(start_cap); }
+    ~RegionAllocator()
+    {
+        if (memory != NULL)
+            ::free(memory);
+    }
+
+
+    uint32_t size      () const      { return sz; }
+    uint32_t wasted    () const      { return wasted_; }
+
+    Ref      alloc     (int size); 
+    void     free      (int size)    { wasted_ += size; }
+
+    // Deref, Load Effective Address (LEA), Inverse of LEA (AEL):
+    T&       operator[](Ref r)       { assert(r >= 0 && r < sz); return memory[r]; }
+    const T& operator[](Ref r) const { assert(r >= 0 && r < sz); return memory[r]; }
+
+    T*       lea       (Ref r)       { assert(r >= 0 && r < sz); return &memory[r]; }
+    const T* lea       (Ref r) const { assert(r >= 0 && r < sz); return &memory[r]; }
+    Ref      ael       (const T* t)  { assert((void*)t >= (void*)&memory[0] && (void*)t < (void*)&memory[sz-1]);
+        return  (Ref)(t - &memory[0]); }
+
+    void     moveTo(RegionAllocator& to) {
+        if (to.memory != NULL) ::free(to.memory);
+        to.memory = memory;
+        to.sz = sz;
+        to.cap = cap;
+        to.wasted_ = wasted_;
+
+        memory = NULL;
+        sz = cap = wasted_ = 0;
+    }
+
+
+};
+
+template<class T>
+void RegionAllocator<T>::capacity(uint32_t min_cap)
+{
+    if (cap >= min_cap) return;
+
+    uint32_t prev_cap = cap;
+    while (cap < min_cap){
+        // NOTE: Multiply by a factor (13/8) without causing overflow, then add 2 and make the
+        // result even by clearing the least significant bit. The resulting sequence of capacities
+        // is carefully chosen to hit a maximum capacity that is close to the '2^32-1' limit when
+        // using 'uint32_t' as indices so that as much as possible of this space can be used.
+        uint32_t delta = ((cap >> 1) + (cap >> 3) + 2) & ~1;
+        cap += delta;
+
+        if (cap <= prev_cap)
+            throw OutOfMemoryException();
+    }
+    // printf(" .. (%p) cap = %u\n", this, cap);
+
+    assert(cap > 0);
+    memory = (T*)xrealloc(memory, sizeof(T)*cap);
+}
+
+
+template<class T>
+typename RegionAllocator<T>::Ref
+RegionAllocator<T>::alloc(int size)
+{ 
+    // printf("ALLOC called (this = %p, size = %d)\n", this, size); fflush(stdout);
+    assert(size > 0);
+    capacity(sz + size);
+
+    uint32_t prev_sz = sz;
+    sz += size;
+    
+    // Handle overflow:
+    if (sz < prev_sz)
+        throw OutOfMemoryException();
+
+    return prev_sz;
+}
+
+
+//=================================================================================================
+}
+
+#endif
diff -ruN src_tmp/minisat/mtl/BasicHeap.h src/minisat/mtl/BasicHeap.h
--- src_tmp/minisat/mtl/BasicHeap.h	1970-01-01 01:00:00.000000000 +0100
+++ src/minisat/mtl/BasicHeap.h	2022-02-19 12:06:50.626500104 +0100
@@ -0,0 +1,98 @@
+/******************************************************************************************[Heap.h]
+MiniSat -- Copyright (c) 2003-2006, Niklas Een, Niklas Sorensson
+
+Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
+associated documentation files (the "Software"), to deal in the Software without restriction,
+including without limitation the rights to use, copy, modify, merge, publish, distribute,
+sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all copies or
+substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
+NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT
+OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+**************************************************************************************************/
+
+#ifndef BasicHeap_h
+#define BasicHeap_h
+
+#include "Vec.h"
+
+//=================================================================================================
+// A heap implementation with support for decrease/increase key.
+
+
+template<class Comp>
+class BasicHeap {
+    Comp     lt;
+    vec<int> heap;     // heap of ints
+
+    // Index "traversal" functions
+    static inline int left  (int i) { return i*2+1; }
+    static inline int right (int i) { return (i+1)*2; }
+    static inline int parent(int i) { return (i-1) >> 1; }
+
+    inline void percolateUp(int i)
+    {
+        int x = heap[i];
+        while (i != 0 && lt(x, heap[parent(i)])){
+            heap[i]          = heap[parent(i)];
+            i                = parent(i);
+        }
+        heap   [i] = x;
+    }
+
+
+    inline void percolateDown(int i)
+    {
+        int x = heap[i];
+        while (left(i) < heap.size()){
+            int child = right(i) < heap.size() && lt(heap[right(i)], heap[left(i)]) ? right(i) : left(i);
+            if (!lt(heap[child], x)) break;
+            heap[i]          = heap[child];
+            i                = child;
+        }
+        heap[i] = x;
+    }
+
+
+    bool heapProperty(int i) {
+        return i >= heap.size()
+            || ((i == 0 || !lt(heap[i], heap[parent(i)])) && heapProperty(left(i)) && heapProperty(right(i))); }
+
+
+  public:
+    BasicHeap(const C& c) : comp(c) { }
+
+    int  size      ()                     const { return heap.size(); }
+    bool empty     ()                     const { return heap.size() == 0; }
+    int  operator[](int index)            const { return heap[index+1]; }
+    void clear     (bool dealloc = false)       { heap.clear(dealloc); }
+    void insert    (int n)                      { heap.push(n); percolateUp(heap.size()-1); }
+
+
+    int  removeMin() {
+        int r   = heap[0];
+        heap[0] = heap.last();
+        heap.pop();
+        if (heap.size() > 1) percolateDown(0);
+        return r; 
+    }
+
+
+    // DEBUG: consistency checking
+    bool heapProperty() {
+        return heapProperty(1); }
+
+
+    // COMPAT: should be removed
+    int  getmin    ()      { return removeMin(); }
+};
+
+
+//=================================================================================================
+#endif
diff -ruN src_tmp/minisat/mtl/BoxedVec.h src/minisat/mtl/BoxedVec.h
--- src_tmp/minisat/mtl/BoxedVec.h	1970-01-01 01:00:00.000000000 +0100
+++ src/minisat/mtl/BoxedVec.h	2022-02-19 12:06:50.626500104 +0100
@@ -0,0 +1,147 @@
+/*******************************************************************************************[Vec.h]
+MiniSat -- Copyright (c) 2003-2006, Niklas Een, Niklas Sorensson
+
+Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
+associated documentation files (the "Software"), to deal in the Software without restriction,
+including without limitation the rights to use, copy, modify, merge, publish, distribute,
+sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all copies or
+substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
+NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT
+OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+**************************************************************************************************/
+
+#ifndef BoxedVec_h
+#define BoxedVec_h
+
+#include <cstdlib>
+#include <cassert>
+#include <new>
+
+//=================================================================================================
+// Automatically resizable arrays
+//
+// NOTE! Don't use this vector on datatypes that cannot be re-located in memory (with realloc)
+
+template<class T>
+class bvec {
+
+    static inline int imin(int x, int y) {
+        int mask = (x-y) >> (sizeof(int)*8-1);
+        return (x&mask) + (y&(~mask)); }
+
+    static inline int imax(int x, int y) {
+        int mask = (y-x) >> (sizeof(int)*8-1);
+        return (x&mask) + (y&(~mask)); }
+
+    struct Vec_t {
+        int sz;
+        int cap;
+        T   data[0];
+
+        static Vec_t* alloc(Vec_t* x, int size){
+            x = (Vec_t*)realloc((void*)x, sizeof(Vec_t) + sizeof(T)*size);
+            x->cap = size;
+            return x;
+        }
+        
+    };
+
+    Vec_t* ref;
+
+    static const int init_size = 2;
+    static int   nextSize (int current) { return (current * 3 + 1) >> 1; }
+    static int   fitSize  (int needed)  { int x; for (x = init_size; needed > x; x = nextSize(x)); return x; }
+
+    void fill (int size) {
+        assert(ref != NULL);
+        for (T* i = ref->data; i < ref->data + size; i++)
+            new (i) T();
+    }
+
+    void fill (int size, const T& pad) {
+        assert(ref != NULL);
+        for (T* i = ref->data; i < ref->data + size; i++)
+            new (i) T(pad);
+    }
+
+    // Don't allow copying (error prone):
+    altvec<T>&  operator = (altvec<T>& other) { assert(0); }
+    altvec (altvec<T>& other)                  { assert(0); }
+
+public:
+    void     clear  (bool dealloc = false) { 
+        if (ref != NULL){
+            for (int i = 0; i < ref->sz; i++) 
+                (*ref).data[i].~T();
+
+            if (dealloc) { 
+                free(ref); ref = NULL; 
+            }else 
+                ref->sz = 0;
+        } 
+    }
+
+    // Constructors:
+    altvec(void)                   : ref (NULL) { }
+    altvec(int size)               : ref (Vec_t::alloc(NULL, fitSize(size))) { fill(size);      ref->sz = size; }
+    altvec(int size, const T& pad) : ref (Vec_t::alloc(NULL, fitSize(size))) { fill(size, pad); ref->sz = size; }
+   ~altvec(void) { clear(true); }
+
+    // Ownership of underlying array:
+    operator T*       (void)           { return ref->data; }     // (unsafe but convenient)
+    operator const T* (void) const     { return ref->data; }
+
+    // Size operations:
+    int      size   (void) const       { return ref != NULL ? ref->sz : 0; }
+
+    void     pop    (void)             { assert(ref != NULL && ref->sz > 0); int last = --ref->sz; ref->data[last].~T(); }
+    void     push   (const T& elem) {
+        int size = ref != NULL ? ref->sz  : 0;
+        int cap  = ref != NULL ? ref->cap : 0;
+        if (size == cap){
+            cap = cap != 0 ? nextSize(cap) : init_size;
+            ref = Vec_t::alloc(ref, cap); 
+        }
+        //new (&ref->data[size]) T(elem); 
+        ref->data[size] = elem; 
+        ref->sz = size+1; 
+    }
+
+    void     push   () {
+        int size = ref != NULL ? ref->sz  : 0;
+        int cap  = ref != NULL ? ref->cap : 0;
+        if (size == cap){
+            cap = cap != 0 ? nextSize(cap) : init_size;
+            ref = Vec_t::alloc(ref, cap); 
+        }
+        new (&ref->data[size]) T(); 
+        ref->sz = size+1; 
+    }
+
+    void     shrink (int nelems)             { for (int i = 0; i < nelems; i++) pop(); }
+    void     shrink_(int nelems)             { for (int i = 0; i < nelems; i++) pop(); }
+    void     growTo (int size)               { while (this->size() < size) push(); }
+    void     growTo (int size, const T& pad) { while (this->size() < size) push(pad); }
+    void     capacity (int size)             { growTo(size); }
+
+    const T& last  (void) const              { return ref->data[ref->sz-1]; }
+    T&       last  (void)                    { return ref->data[ref->sz-1]; }
+
+    // Vector interface:
+    const T& operator [] (int index) const  { return ref->data[index]; }
+    T&       operator [] (int index)        { return ref->data[index]; }
+
+    void copyTo(altvec<T>& copy) const { copy.clear(); for (int i = 0; i < size(); i++) copy.push(ref->data[i]); }
+    void moveTo(altvec<T>& dest) { dest.clear(true); dest.ref = ref; ref = NULL; }
+
+};
+
+
+#endif
diff -ruN src_tmp/minisat/mtl/config.mk src/minisat/mtl/config.mk
--- src_tmp/minisat/mtl/config.mk	1970-01-01 01:00:00.000000000 +0100
+++ src/minisat/mtl/config.mk	2022-02-19 12:06:50.626500104 +0100
@@ -0,0 +1,6 @@
+##
+##  This file is for system specific configurations. For instance, on
+##  some systems the path to zlib needs to be added. Example:
+##
+##  CFLAGS += -I/usr/local/include
+##  LFLAGS += -L/usr/local/lib
diff -ruN src_tmp/minisat/mtl/Heap.h src/minisat/mtl/Heap.h
--- src_tmp/minisat/mtl/Heap.h	1970-01-01 01:00:00.000000000 +0100
+++ src/minisat/mtl/Heap.h	2022-02-19 12:06:50.626500104 +0100
@@ -0,0 +1,169 @@
+/******************************************************************************************[Heap.h]
+MiniSat -- Copyright (c) 2003-2006, Niklas Een, Niklas Sorensson
+
+Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
+associated documentation files (the "Software"), to deal in the Software without restriction,
+including without limitation the rights to use, copy, modify, merge, publish, distribute,
+sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all copies or
+substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
+NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT
+OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+**************************************************************************************************/
+
+#ifndef Heap_h
+#define Heap_h
+
+#include "Vec.h"
+
+//=================================================================================================
+// A heap implementation with support for decrease/increase key.
+
+
+template<class Comp>
+class Heap {
+    Comp     lt;
+    vec<int> heap;     // heap of ints
+    vec<int> indices;  // int -> index in heap
+
+    // Index "traversal" functions
+    static inline int left  (int i) { return i*2+1; }
+    static inline int right (int i) { return (i+1)*2; }
+    static inline int parent(int i) { return (i-1) >> 1; }
+
+
+    inline void percolateUp(int i)
+    {
+        int x = heap[i];
+        while (i != 0 && lt(x, heap[parent(i)])){
+            heap[i]          = heap[parent(i)];
+            indices[heap[i]] = i;
+            i                = parent(i);
+        }
+        heap   [i] = x;
+        indices[x] = i;
+    }
+
+
+    inline void percolateDown(int i)
+    {
+        int x = heap[i];
+        while (left(i) < heap.size()){
+            int child = right(i) < heap.size() && lt(heap[right(i)], heap[left(i)]) ? right(i) : left(i);
+            if (!lt(heap[child], x)) break;
+            heap[i]          = heap[child];
+            indices[heap[i]] = i;
+            i                = child;
+        }
+        heap   [i] = x;
+        indices[x] = i;
+    }
+
+
+    bool heapProperty (int i) const {
+        return i >= heap.size()
+            || ((i == 0 || !lt(heap[i], heap[parent(i)])) && heapProperty(left(i)) && heapProperty(right(i))); }
+
+
+  public:
+    Heap(const Comp& c) : lt(c) { }
+
+    int  size      ()          const { return heap.size(); }
+    bool empty     ()          const { return heap.size() == 0; }
+    bool inHeap    (int n)     const { return n < indices.size() && indices[n] >= 0; }
+    int  operator[](int index) const { assert(index < heap.size()); return heap[index]; }
+
+    void decrease  (int n) { assert(inHeap(n)); percolateUp(indices[n]); }
+
+    // RENAME WHEN THE DEPRECATED INCREASE IS REMOVED.
+    void increase_ (int n) { assert(inHeap(n)); percolateDown(indices[n]); }
+
+
+    void insert(int n)
+    {
+        indices.growTo(n+1, -1);
+        assert(!inHeap(n));
+
+        indices[n] = heap.size();
+        heap.push(n);
+        percolateUp(indices[n]); 
+    }
+
+
+    int  removeMin()
+    {
+        int x            = heap[0];
+        heap[0]          = heap.last();
+        indices[heap[0]] = 0;
+        indices[x]       = -1;
+        heap.pop();
+        if (heap.size() > 1) percolateDown(0);
+        return x; 
+    }
+
+
+    void clear(bool dealloc = false) 
+    { 
+        for (int i = 0; i < heap.size(); i++)
+            indices[heap[i]] = -1;
+#ifdef NDEBUG
+        for (int i = 0; i < indices.size(); i++)
+            assert(indices[i] == -1);
+#endif
+        heap.clear(dealloc); 
+    }
+
+
+    // Fool proof variant of insert/decrease/increase
+    void update (int n)
+    {
+        if (!inHeap(n))
+            insert(n);
+        else {
+            percolateUp(indices[n]);
+            percolateDown(indices[n]);
+        }
+    }
+
+
+    // Delete elements from the heap using a given filter function (-object).
+    // *** this could probaly be replaced with a more general "buildHeap(vec<int>&)" method ***
+    template <class F>
+    void filter(const F& filt) {
+        int i,j;
+        for (i = j = 0; i < heap.size(); i++)
+            if (filt(heap[i])){
+                heap[j]          = heap[i];
+                indices[heap[i]] = j++;
+            }else
+                indices[heap[i]] = -1;
+
+        heap.shrink(i - j);
+        for (int i = heap.size() / 2 - 1; i >= 0; i--)
+            percolateDown(i);
+
+        assert(heapProperty());
+    }
+
+
+    // DEBUG: consistency checking
+    bool heapProperty() const {
+        return heapProperty(1); }
+
+
+    // COMPAT: should be removed
+    void setBounds (int n) { }
+    void increase  (int n) { decrease(n); }
+    int  getmin    ()      { return removeMin(); }
+
+};
+
+
+//=================================================================================================
+#endif
diff -ruN src_tmp/minisat/mtl/IntTypes.h src/minisat/mtl/IntTypes.h
--- src_tmp/minisat/mtl/IntTypes.h	1970-01-01 01:00:00.000000000 +0100
+++ src/minisat/mtl/IntTypes.h	2022-02-19 12:06:50.626500104 +0100
@@ -0,0 +1,42 @@
+/**************************************************************************************[IntTypes.h]
+Copyright (c) 2009-2010, Niklas Sorensson
+
+Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
+associated documentation files (the "Software"), to deal in the Software without restriction,
+including without limitation the rights to use, copy, modify, merge, publish, distribute,
+sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all copies or
+substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
+NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT
+OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+**************************************************************************************************/
+
+#ifndef Minisat_IntTypes_h
+#define Minisat_IntTypes_h
+
+#ifdef __sun
+    // Not sure if there are newer versions that support C99 headers. The
+    // needed features are implemented in the headers below though:
+
+#   include <sys/int_types.h>
+#   include <sys/int_fmtio.h>
+#   include <sys/int_limits.h>
+
+#else
+
+#   include <stdint.h>
+#   include <inttypes.h>
+
+#endif
+
+#include <limits.h>
+
+//=================================================================================================
+
+#endif
diff -ruN src_tmp/minisat/mtl/Map.h src/minisat/mtl/Map.h
--- src_tmp/minisat/mtl/Map.h	1970-01-01 01:00:00.000000000 +0100
+++ src/minisat/mtl/Map.h	2022-02-19 12:06:50.626500104 +0100
@@ -0,0 +1,118 @@
+/*******************************************************************************************[Map.h]
+MiniSat -- Copyright (c) 2003-2006, Niklas Een, Niklas Sorensson
+
+Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
+associated documentation files (the "Software"), to deal in the Software without restriction,
+including without limitation the rights to use, copy, modify, merge, publish, distribute,
+sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all copies or
+substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
+NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT
+OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+**************************************************************************************************/
+
+#ifndef Map_h
+#define Map_h
+
+#include <stdint.h>
+
+#include "Vec.h"
+
+//=================================================================================================
+// Default hash/equals functions
+//
+
+template<class K> struct Hash  { uint32_t operator()(const K& k)               const { return hash(k);  } };
+template<class K> struct Equal { bool     operator()(const K& k1, const K& k2) const { return k1 == k2; } };
+
+template<class K> struct DeepHash  { uint32_t operator()(const K* k)               const { return hash(*k);  } };
+template<class K> struct DeepEqual { bool     operator()(const K* k1, const K* k2) const { return *k1 == *k2; } };
+
+//=================================================================================================
+// Some primes
+//
+
+static const int nprimes          = 25;
+static const int primes [nprimes] = { 31, 73, 151, 313, 643, 1291, 2593, 5233, 10501, 21013, 42073, 84181, 168451, 337219, 674701, 1349473, 2699299, 5398891, 10798093, 21596719, 43193641, 86387383, 172775299, 345550609, 691101253 };
+
+//=================================================================================================
+// Hash table implementation of Maps
+//
+
+template<class K, class D, class H = Hash<K>, class E = Equal<K> >
+class Map {
+    struct Pair { K key; D data; };
+
+    H          hash;
+    E          equals;
+
+    vec<Pair>* table;
+    int        cap;
+    int        size;
+
+    // Don't allow copying (error prone):
+    Map<K,D,H,E>&  operator = (Map<K,D,H,E>& other) { assert(0); }
+                   Map        (Map<K,D,H,E>& other) { assert(0); }
+
+    int32_t index  (const K& k) const { return hash(k) % cap; }
+    void   _insert (const K& k, const D& d) { table[index(k)].push(); table[index(k)].last().key = k; table[index(k)].last().data = d; }
+    void    rehash () {
+        const vec<Pair>* old = table;
+
+        int newsize = primes[0];
+        for (int i = 1; newsize <= cap && i < nprimes; i++)
+           newsize = primes[i];
+
+        table = new vec<Pair>[newsize];
+
+        for (int i = 0; i < cap; i++){
+            for (int j = 0; j < old[i].size(); j++){
+                _insert(old[i][j].key, old[i][j].data); }}
+
+        delete [] old;
+
+        cap = newsize;
+    }
+
+    
+    public:
+
+     Map () : table(NULL), cap(0), size(0) {}
+     Map (const H& h, const E& e) : Map(), hash(h), equals(e) {}
+    ~Map () { delete [] table; }
+
+    void insert (const K& k, const D& d) { if (size+1 > cap / 2) rehash(); _insert(k, d); size++; }
+    bool peek   (const K& k, D& d) {
+        if (size == 0) return false;
+        const vec<Pair>& ps = table[index(k)];
+        for (int i = 0; i < ps.size(); i++)
+            if (equals(ps[i].key, k)){
+                d = ps[i].data;
+                return true; } 
+        return false;
+    }
+
+    void remove (const K& k) {
+        assert(table != NULL);
+        vec<Pair>& ps = table[index(k)];
+        int j = 0;
+        for (; j < ps.size() && !equals(ps[j].key, k); j++);
+        assert(j < ps.size());
+        ps[j] = ps.last();
+        ps.pop();
+    }
+
+    void clear  () {
+        cap = size = 0;
+        delete [] table;
+        table = NULL;
+    }
+};
+
+#endif
diff -ruN src_tmp/minisat/mtl/Queue.h src/minisat/mtl/Queue.h
--- src_tmp/minisat/mtl/Queue.h	1970-01-01 01:00:00.000000000 +0100
+++ src/minisat/mtl/Queue.h	2022-02-19 12:06:50.626500104 +0100
@@ -0,0 +1,82 @@
+/*****************************************************************************************[Queue.h]
+MiniSat -- Copyright (c) 2003-2006, Niklas Een, Niklas Sorensson
+
+Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
+associated documentation files (the "Software"), to deal in the Software without restriction,
+including without limitation the rights to use, copy, modify, merge, publish, distribute,
+sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all copies or
+substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
+NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT
+OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+**************************************************************************************************/
+
+#ifndef Queue_h
+#define Queue_h
+
+#include "Vec.h"
+
+//=================================================================================================
+
+
+template <class T>
+class Queue {
+    vec<T>  elems;
+    int     first;
+
+public:
+    Queue(void) : first(0) { }
+
+    void insert(T x)   { elems.push(x); }
+    T    peek  () const { return elems[first]; }
+    void pop   () { first++; }
+
+    void clear(bool dealloc = false)   { elems.clear(dealloc); first = 0; }
+    int  size(void)    { return elems.size() - first; }
+
+    //bool has(T x) { for (int i = first; i < elems.size(); i++) if (elems[i] == x) return true; return false; }
+
+    const T& operator [] (int index) const  { return elems[first + index]; }
+
+};
+
+//template<class T>
+//class Queue {
+//    vec<T>  buf;
+//    int     first;
+//    int     end;
+//
+//public:
+//    typedef T Key;
+//
+//    Queue() : buf(1), first(0), end(0) {}
+//
+//    void clear () { buf.shrinkTo(1); first = end = 0; }
+//    int  size  () { return (end >= first) ? end - first : end - first + buf.size(); }
+//
+//    T    peek  () { assert(first != end); return buf[first]; }
+//    void pop   () { assert(first != end); first++; if (first == buf.size()) first = 0; }
+//    void insert(T elem) {   // INVARIANT: buf[end] is always unused
+//        buf[end++] = elem;
+//        if (end == buf.size()) end = 0;
+//        if (first == end){  // Resize:
+//            vec<T>  tmp((buf.size()*3 + 1) >> 1);
+//            //**/printf("queue alloc: %d elems (%.1f MB)\n", tmp.size(), tmp.size() * sizeof(T) / 1000000.0);
+//            int     i = 0;
+//            for (int j = first; j < buf.size(); j++) tmp[i++] = buf[j];
+//            for (int j = 0    ; j < end       ; j++) tmp[i++] = buf[j];
+//            first = 0;
+//            end   = buf.size();
+//            tmp.moveTo(buf);
+//        }
+//    }
+//};
+
+//=================================================================================================
+#endif
diff -ruN src_tmp/minisat/mtl/Sort.h src/minisat/mtl/Sort.h
--- src_tmp/minisat/mtl/Sort.h	1970-01-01 01:00:00.000000000 +0100
+++ src/minisat/mtl/Sort.h	2022-02-19 12:06:50.626500104 +0100
@@ -0,0 +1,93 @@
+/******************************************************************************************[Sort.h]
+MiniSat -- Copyright (c) 2003-2006, Niklas Een, Niklas Sorensson
+
+Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
+associated documentation files (the "Software"), to deal in the Software without restriction,
+including without limitation the rights to use, copy, modify, merge, publish, distribute,
+sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all copies or
+substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
+NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT
+OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+**************************************************************************************************/
+
+#ifndef Sort_h
+#define Sort_h
+
+#include "Vec.h"
+
+//=================================================================================================
+// Some sorting algorithms for vec's
+
+
+template<class T>
+struct LessThan_default {
+    bool operator () (T x, T y) { return x < y; }
+};
+
+
+template <class T, class LessThan>
+void selectionSort(T* array, int size, LessThan lt)
+{
+    int     i, j, best_i;
+    T       tmp;
+
+    for (i = 0; i < size-1; i++){
+        best_i = i;
+        for (j = i+1; j < size; j++){
+            if (lt(array[j], array[best_i]))
+                best_i = j;
+        }
+        tmp = array[i]; array[i] = array[best_i]; array[best_i] = tmp;
+    }
+}
+template <class T> static inline void selectionSort(T* array, int size) {
+    selectionSort(array, size, LessThan_default<T>()); }
+
+template <class T, class LessThan>
+void sort(T* array, int size, LessThan lt)
+{
+    if (size <= 15)
+        selectionSort(array, size, lt);
+
+    else{
+        T           pivot = array[size / 2];
+        T           tmp;
+        int         i = -1;
+        int         j = size;
+
+        for(;;){
+            do i++; while(lt(array[i], pivot));
+            do j--; while(lt(pivot, array[j]));
+
+            if (i >= j) break;
+
+            tmp = array[i]; array[i] = array[j]; array[j] = tmp;
+        }
+
+        sort(array    , i     , lt);
+        sort(&array[i], size-i, lt);
+    }
+}
+template <class T> static inline void sort(T* array, int size) {
+    sort(array, size, LessThan_default<T>()); }
+
+
+//=================================================================================================
+// For 'vec's:
+
+
+template <class T, class LessThan> void sort(vec<T>& v, LessThan lt) {
+    sort((T*)v, v.size(), lt); }
+template <class T> void sort(vec<T>& v) {
+    sort(v, LessThan_default<T>()); }
+
+
+//=================================================================================================
+#endif
diff -ruN src_tmp/minisat/mtl/template.mk src/minisat/mtl/template.mk
--- src_tmp/minisat/mtl/template.mk	1970-01-01 01:00:00.000000000 +0100
+++ src/minisat/mtl/template.mk	2022-02-19 12:06:50.626500104 +0100
@@ -0,0 +1,90 @@
+##
+##  Template makefile for Standard, Profile, Debug, Release, and Release-static versions
+##
+##    eg: "make rs" for a statically linked release version.
+##        "make d"  for a debug version (no optimizations).
+##        "make"    for the standard version (optimized, but with debug information and assertions active)
+
+CSRCS     ?= $(wildcard *.C)
+CHDRS     ?= $(wildcard *.h)
+COBJS     ?= $(addsuffix .o, $(basename $(CSRCS)))
+
+PCOBJS     = $(addsuffix p,  $(COBJS))
+DCOBJS     = $(addsuffix d,  $(COBJS))
+RCOBJS     = $(addsuffix r,  $(COBJS))
+
+EXEC      ?= $(notdir $(shell pwd))
+LIB       ?= $(EXEC)
+
+CXX       ?= g++
+CFLAGS    ?= -Wall
+LFLAGS    ?= -Wall
+
+COPTIMIZE ?= -O3
+
+.PHONY : s p d r rs lib libd clean 
+
+s:	$(EXEC)
+p:	$(EXEC)_profile
+d:	$(EXEC)_debug
+r:	$(EXEC)_release
+rs:	$(EXEC)_static
+lib:	lib$(LIB).a
+libd:	lib$(LIB)d.a
+
+## Compile options
+%.o:			CFLAGS +=$(COPTIMIZE) -ggdb -D DEBUG
+%.op:			CFLAGS +=$(COPTIMIZE) -pg -ggdb -D NDEBUG
+%.od:			CFLAGS +=-O0 -ggdb -D DEBUG # -D INVARIANTS
+%.or:			CFLAGS +=$(COPTIMIZE) -D NDEBUG
+
+## Link options
+$(EXEC):		LFLAGS := -ggdb $(LFLAGS)
+$(EXEC)_profile:	LFLAGS := -ggdb -pg $(LFLAGS)
+$(EXEC)_debug:		LFLAGS := -ggdb $(LFLAGS)
+$(EXEC)_release:	LFLAGS := $(LFLAGS)
+$(EXEC)_static:		LFLAGS := --static $(LFLAGS)
+
+## Dependencies
+$(EXEC):		$(COBJS)
+$(EXEC)_profile:	$(PCOBJS)
+$(EXEC)_debug:		$(DCOBJS)
+$(EXEC)_release:	$(RCOBJS)
+$(EXEC)_static:		$(RCOBJS)
+
+lib$(LIB).a:	$(filter-out Main.or, $(RCOBJS))
+lib$(LIB)d.a:	$(filter-out Main.od, $(DCOBJS))
+
+
+## Build rule
+%.o %.op %.od %.or:	%.C
+	@echo Compiling: "$@ ( $< )"
+	@$(CXX) $(CFLAGS) -c -o $@ $<
+
+## Linking rules (standard/profile/debug/release)
+$(EXEC) $(EXEC)_profile $(EXEC)_debug $(EXEC)_release $(EXEC)_static:
+	@echo Linking: "$@ ( $^ )"
+	@$(CXX) $^ $(LFLAGS) -o $@
+
+## Library rule
+lib$(LIB).a lib$(LIB)d.a:
+	@echo Library: "$@ ( $^ )"
+	@rm -f $@
+	@ar cq $@ $^
+
+## Clean rule
+clean:
+	@rm -f $(EXEC) $(EXEC)_profile $(EXEC)_debug $(EXEC)_release $(EXEC)_static \
+	  $(COBJS) $(PCOBJS) $(DCOBJS) $(RCOBJS) *.core depend.mak lib$(LIB).a lib$(LIB)d.a
+
+## Make dependencies
+depend.mk: $(CSRCS) $(CHDRS)
+	@echo Making dependencies ...
+	@$(CXX) $(CFLAGS) -MM $(CSRCS) > depend.mk
+	@cp depend.mk /tmp/depend.mk.tmp
+	@sed "s/o:/op:/" /tmp/depend.mk.tmp >> depend.mk
+	@sed "s/o:/od:/" /tmp/depend.mk.tmp >> depend.mk
+	@sed "s/o:/or:/" /tmp/depend.mk.tmp >> depend.mk
+	@rm /tmp/depend.mk.tmp
+
+-include depend.mk
diff -ruN src_tmp/minisat/mtl/Vec.h src/minisat/mtl/Vec.h
--- src_tmp/minisat/mtl/Vec.h	1970-01-01 01:00:00.000000000 +0100
+++ src/minisat/mtl/Vec.h	2022-02-19 12:06:50.626500104 +0100
@@ -0,0 +1,133 @@
+/*******************************************************************************************[Vec.h]
+MiniSat -- Copyright (c) 2003-2006, Niklas Een, Niklas Sorensson
+
+Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
+associated documentation files (the "Software"), to deal in the Software without restriction,
+including without limitation the rights to use, copy, modify, merge, publish, distribute,
+sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all copies or
+substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
+NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT
+OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+**************************************************************************************************/
+
+#ifndef Vec_h
+#define Vec_h
+
+#include <cstdlib>
+#include <cassert>
+#include <new>
+
+//=================================================================================================
+// Automatically resizable arrays
+//
+// NOTE! Don't use this vector on datatypes that cannot be re-located in memory (with realloc)
+
+template<class T>
+class vec {
+    T*  data;
+    int sz;
+    int cap;
+
+    void     init(int size, const T& pad);
+    void     grow(int min_cap);
+
+    // Don't allow copying (error prone):
+    vec<T>&  operator = (vec<T>& other) { assert(0); return *this; }
+             vec        (vec<T>& other) { assert(0); }
+
+    static inline int imin(int x, int y) {
+        int mask = (x-y) >> (sizeof(int)*8-1);
+        return (x&mask) + (y&(~mask)); }
+
+    static inline int imax(int x, int y) {
+        int mask = (y-x) >> (sizeof(int)*8-1);
+        return (x&mask) + (y&(~mask)); }
+
+public:
+    // Types:
+    typedef int Key;
+    typedef T   Datum;
+
+    // Constructors:
+    vec(void)                   : data(NULL) , sz(0)   , cap(0)    { }
+    vec(int size)               : data(NULL) , sz(0)   , cap(0)    { growTo(size); }
+    vec(int size, const T& pad) : data(NULL) , sz(0)   , cap(0)    { growTo(size, pad); }
+    vec(T* array, int size)     : data(array), sz(size), cap(size) { }      // (takes ownership of array -- will be deallocated with 'free()')
+   ~vec(void)                                                      { clear(true); }
+
+    // Ownership of underlying array:
+    T*       release  (void)           { T* ret = data; data = NULL; sz = 0; cap = 0; return ret; }
+    operator T*       (void)           { return data; }     // (unsafe but convenient)
+    operator const T* (void) const     { return data; }
+
+    // Size operations:
+    int      size   (void) const       { return sz; }
+    void     shrink (int nelems)       { assert(nelems <= sz); for (int i = 0; i < nelems; i++) sz--, data[sz].~T(); }
+    void     shrink_(int nelems)       { assert(nelems <= sz); sz -= nelems; }
+    void     pop    (void)             { sz--, data[sz].~T(); }
+    void     growTo (int size);
+    void     growTo (int size, const T& pad);
+    void     clear  (bool dealloc = false);
+    void     capacity (int size) { grow(size); }
+
+    // Stack interface:
+#if 1
+    void     push  (void)              { if (sz == cap) { cap = imax(2, (cap*3+1)>>1); data = (T*)realloc(data, cap * sizeof(T)); } new (&data[sz]) T(); sz++; }
+    //void     push  (const T& elem)     { if (sz == cap) { cap = imax(2, (cap*3+1)>>1); data = (T*)realloc(data, cap * sizeof(T)); } new (&data[sz]) T(elem); sz++; }
+    void     push  (const T& elem)     { if (sz == cap) { cap = imax(2, (cap*3+1)>>1); data = (T*)realloc(data, cap * sizeof(T)); } data[sz++] = elem; }
+    void     push_ (const T& elem)     { assert(sz < cap); data[sz++] = elem; }
+#else
+    void     push  (void)              { if (sz == cap) grow(sz+1); new (&data[sz]) T()    ; sz++; }
+    void     push  (const T& elem)     { if (sz == cap) grow(sz+1); new (&data[sz]) T(elem); sz++; }
+#endif
+
+    const T& last  (void) const        { return data[sz-1]; }
+    T&       last  (void)              { return data[sz-1]; }
+
+    // Vector interface:
+    const T& operator [] (int index) const  { return data[index]; }
+    T&       operator [] (int index)        { return data[index]; }
+
+
+    // Duplicatation (preferred instead):
+    void copyTo(vec<T>& copy) const { copy.clear(); copy.growTo(sz); for (int i = 0; i < sz; i++) new (&copy[i]) T(data[i]); }
+    void moveTo(vec<T>& dest) { dest.clear(true); dest.data = data; dest.sz = sz; dest.cap = cap; data = NULL; sz = 0; cap = 0; }
+};
+
+template<class T>
+void vec<T>::grow(int min_cap) {
+    if (min_cap <= cap) return;
+    if (cap == 0) cap = (min_cap >= 2) ? min_cap : 2;
+    else          do cap = (cap*3+1) >> 1; while (cap < min_cap);
+    data = (T*)realloc(data, cap * sizeof(T)); }
+
+template<class T>
+void vec<T>::growTo(int size, const T& pad) {
+    if (sz >= size) return;
+    grow(size);
+    for (int i = sz; i < size; i++) new (&data[i]) T(pad);
+    sz = size; }
+
+template<class T>
+void vec<T>::growTo(int size) {
+    if (sz >= size) return;
+    grow(size);
+    for (int i = sz; i < size; i++) new (&data[i]) T();
+    sz = size; }
+
+template<class T>
+void vec<T>::clear(bool dealloc) {
+    if (data != NULL){
+        for (int i = 0; i < sz; i++) data[i].~T();
+        sz = 0;
+        if (dealloc) free(data), data = NULL, cap = 0; } }
+
+
+#endif
diff -ruN src_tmp/minisat/mtl/XAlloc.h src/minisat/mtl/XAlloc.h
--- src_tmp/minisat/mtl/XAlloc.h	1970-01-01 01:00:00.000000000 +0100
+++ src/minisat/mtl/XAlloc.h	2022-02-19 12:06:50.626500104 +0100
@@ -0,0 +1,45 @@
+/****************************************************************************************[XAlloc.h]
+Copyright (c) 2009-2010, Niklas Sorensson
+
+Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
+associated documentation files (the "Software"), to deal in the Software without restriction,
+including without limitation the rights to use, copy, modify, merge, publish, distribute,
+sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all copies or
+substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
+NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT
+OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+**************************************************************************************************/
+
+
+#ifndef Minisat_XAlloc_h
+#define Minisat_XAlloc_h
+
+#include <errno.h>
+#include <stdlib.h>
+
+namespace Minisat {
+
+//=================================================================================================
+// Simple layer on top of malloc/realloc to catch out-of-memory situtaions and provide some typing:
+
+class OutOfMemoryException{};
+static inline void* xrealloc(void *ptr, size_t size)
+{
+    void* mem = realloc(ptr, size);
+    if (mem == NULL && errno == ENOMEM){
+        throw OutOfMemoryException();
+    }else
+        return mem;
+}
+
+//=================================================================================================
+}
+
+#endif
diff -ruN src_tmp/minisat/README src/minisat/README
--- src_tmp/minisat/README	1970-01-01 01:00:00.000000000 +0100
+++ src/minisat/README	2022-02-19 12:06:50.626500104 +0100
@@ -0,0 +1,24 @@
+================================================================================
+DIRECTORY OVERVIEW:
+
+mtl/            Mini Template Library
+utils/          Generic helper code (I/O, Parsing, CPU-time, etc)
+core/           A core version of the solver
+simp/           An extended solver with simplification capabilities
+README
+LICENSE
+
+================================================================================
+BUILDING: (release version: without assertions, statically linked, etc)
+
+export MROOT=<minisat-dir>              (or setenv in cshell)
+cd { core | simp }
+gmake rs
+cp minisat_static <install-dir>/minisat
+
+================================================================================
+EXAMPLES:
+
+Run minisat with same heuristics as version 2.0:
+
+> minisat <cnf-file> -no-luby -rinc=1.5 -phase-saving=0 -rnd-freq=0.02
diff -ruN src_tmp/minisat/simp/Main.cc src/minisat/simp/Main.cc
--- src_tmp/minisat/simp/Main.cc	1970-01-01 01:00:00.000000000 +0100
+++ src/minisat/simp/Main.cc	2022-02-19 12:06:50.626500104 +0100
@@ -0,0 +1,211 @@
+/*****************************************************************************************[Main.cc]
+Copyright (c) 2003-2006, Niklas Een, Niklas Sorensson
+Copyright (c) 2007,      Niklas Sorensson
+
+Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
+associated documentation files (the "Software"), to deal in the Software without restriction,
+including without limitation the rights to use, copy, modify, merge, publish, distribute,
+sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all copies or
+substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
+NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT
+OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+**************************************************************************************************/
+
+#include <errno.h>
+
+#include <signal.h>
+#include <zlib.h>
+#include <sys/resource.h>
+
+#include "utils/System.h"
+#include "utils/ParseUtils.h"
+#include "utils/Options.h"
+#include "core/Dimacs.h"
+#include "simp/SimpSolver.h"
+
+using namespace Minisat;
+
+//=================================================================================================
+
+
+void printStats(Solver& solver)
+{
+    double cpu_time = cpuTime();
+    double mem_used = memUsedPeak();
+    printf("restarts              : %"PRIu64"\n", solver.starts);
+    printf("conflicts             : %-12"PRIu64"   (%.0f /sec)\n", solver.conflicts   , solver.conflicts   /cpu_time);
+    printf("decisions             : %-12"PRIu64"   (%4.2f %% random) (%.0f /sec)\n", solver.decisions, (float)solver.rnd_decisions*100 / (float)solver.decisions, solver.decisions   /cpu_time);
+    printf("propagations          : %-12"PRIu64"   (%.0f /sec)\n", solver.propagations, solver.propagations/cpu_time);
+    printf("conflict literals     : %-12"PRIu64"   (%4.2f %% deleted)\n", solver.tot_literals, (solver.max_literals - solver.tot_literals)*100 / (double)solver.max_literals);
+    if (mem_used != 0) printf("Memory used           : %.2f MB\n", mem_used);
+    printf("CPU time              : %g s\n", cpu_time);
+}
+
+
+static Solver* solver;
+// Terminate by notifying the solver and back out gracefully. This is mainly to have a test-case
+// for this feature of the Solver as it may take longer than an immediate call to '_exit()'.
+static void SIGINT_interrupt(int signum) { solver->interrupt(); }
+
+// Note that '_exit()' rather than 'exit()' has to be used. The reason is that 'exit()' calls
+// destructors and may cause deadlocks if a malloc/free function happens to be running (these
+// functions are guarded by locks for multithreaded use).
+static void SIGINT_exit(int signum) {
+    printf("\n"); printf("*** INTERRUPTED ***\n");
+    if (solver->verbosity > 0){
+        printStats(*solver);
+        printf("\n"); printf("*** INTERRUPTED ***\n"); }
+    _exit(1); }
+
+
+//=================================================================================================
+// Main:
+
+int main(int argc, char** argv)
+{
+    try {
+        setUsageHelp("USAGE: %s [options] <input-file> <result-output-file>\n\n  where input may be either in plain or gzipped DIMACS.\n");
+        // printf("This is MiniSat 2.0 beta\n");
+        
+#if defined(__linux__)
+        fpu_control_t oldcw, newcw;
+        _FPU_GETCW(oldcw); newcw = (oldcw & ~_FPU_EXTENDED) | _FPU_DOUBLE; _FPU_SETCW(newcw);
+        printf("WARNING: for repeatability, setting FPU to use double precision\n");
+#endif
+        // Extra options:
+        //
+        IntOption    verb   ("MAIN", "verb",   "Verbosity level (0=silent, 1=some, 2=more).", 1, IntRange(0, 2));
+        BoolOption   pre    ("MAIN", "pre",    "Completely turn on/off any preprocessing.", true);
+        StringOption dimacs ("MAIN", "dimacs", "If given, stop after preprocessing and write the result to this file.");
+        IntOption    cpu_lim("MAIN", "cpu-lim","Limit on CPU time allowed in seconds.\n", INT32_MAX, IntRange(0, INT32_MAX));
+        IntOption    mem_lim("MAIN", "mem-lim","Limit on memory usage in megabytes.\n", INT32_MAX, IntRange(0, INT32_MAX));
+
+        parseOptions(argc, argv, true);
+        
+        SimpSolver  S;
+        double      initial_time = cpuTime();
+
+        if (!pre) S.eliminate(true);
+
+        S.verbosity = verb;
+        
+        solver = &S;
+        // Use signal handlers that forcibly quit until the solver will be able to respond to
+        // interrupts:
+        signal(SIGINT, SIGINT_exit);
+        signal(SIGXCPU,SIGINT_exit);
+
+        // Set limit on CPU-time:
+        if (cpu_lim != INT32_MAX){
+            rlimit rl;
+            getrlimit(RLIMIT_CPU, &rl);
+            if (rl.rlim_max == RLIM_INFINITY || (rlim_t)cpu_lim < rl.rlim_max){
+                rl.rlim_cur = cpu_lim;
+                if (setrlimit(RLIMIT_CPU, &rl) == -1)
+                    printf("WARNING! Could not set resource limit: CPU-time.\n");
+            } }
+
+        // Set limit on virtual memory:
+        if (mem_lim != INT32_MAX){
+            rlim_t new_mem_lim = (rlim_t)mem_lim * 1024*1024;
+            rlimit rl;
+            getrlimit(RLIMIT_AS, &rl);
+            if (rl.rlim_max == RLIM_INFINITY || new_mem_lim < rl.rlim_max){
+                rl.rlim_cur = new_mem_lim;
+                if (setrlimit(RLIMIT_AS, &rl) == -1)
+                    printf("WARNING! Could not set resource limit: Virtual memory.\n");
+            } }
+        
+        if (argc == 1)
+            printf("Reading from standard input... Use '--help' for help.\n");
+
+        gzFile in = (argc == 1) ? gzdopen(0, "rb") : gzopen(argv[1], "rb");
+        if (in == NULL)
+            printf("ERROR! Could not open file: %s\n", argc == 1 ? "<stdin>" : argv[1]), exit(1);
+        
+        if (S.verbosity > 0){
+            printf("============================[ Problem Statistics ]=============================\n");
+            printf("|                                                                             |\n"); }
+        
+        parse_DIMACS(in, S);
+        gzclose(in);
+        FILE* res = (argc >= 3) ? fopen(argv[2], "wb") : NULL;
+
+        if (S.verbosity > 0){
+            printf("|  Number of variables:  %12d                                         |\n", S.nVars());
+            printf("|  Number of clauses:    %12d                                         |\n", S.nClauses()); }
+        
+        double parsed_time = cpuTime();
+        if (S.verbosity > 0)
+            printf("|  Parse time:           %12.2f s                                       |\n", parsed_time - initial_time);
+
+        // Change to signal-handlers that will only notify the solver and allow it to terminate
+        // voluntarily:
+        signal(SIGINT, SIGINT_interrupt);
+        signal(SIGXCPU,SIGINT_interrupt);
+
+        S.eliminate(true);
+        double simplified_time = cpuTime();
+        if (S.verbosity > 0){
+            printf("|  Simplification time:  %12.2f s                                       |\n", simplified_time - parsed_time);
+            printf("|                                                                             |\n"); }
+
+        if (!S.okay()){
+            if (res != NULL) fprintf(res, "UNSAT\n"), fclose(res);
+            if (S.verbosity > 0){
+                printf("===============================================================================\n");
+                printf("Solved by simplification\n");
+                printStats(S);
+                printf("\n"); }
+            printf("UNSATISFIABLE\n");
+            exit(20);
+        }
+
+        if (dimacs){
+            if (S.verbosity > 0)
+                printf("==============================[ Writing DIMACS ]===============================\n");
+            S.toDimacs((const char*)dimacs);
+            if (S.verbosity > 0)
+                printStats(S);
+            exit(0);
+        }
+
+        vec<Lit> dummy;
+        lbool ret = S.solveLimited(dummy);
+        
+        if (S.verbosity > 0){
+            printStats(S);
+            printf("\n"); }
+        printf(ret == l_True ? "SATISFIABLE\n" : ret == l_False ? "UNSATISFIABLE\n" : "INDETERMINATE\n");
+        if (res != NULL){
+            if (ret == l_True){
+                fprintf(res, "SAT\n");
+                for (int i = 0; i < S.nVars(); i++)
+                    if (S.model[i] != l_Undef)
+                        fprintf(res, "%s%s%d", (i==0)?"":" ", (S.model[i]==l_True)?"":"-", i+1);
+                fprintf(res, " 0\n");
+            }else if (ret == l_False)
+                fprintf(res, "UNSAT\n");
+            else
+                fprintf(res, "INDET\n");
+            fclose(res);
+        }
+
+#ifdef NDEBUG
+        exit(ret == l_True ? 10 : ret == l_False ? 20 : 0);     // (faster than "return", which will invoke the destructor for 'Solver')
+#else
+        return (ret == l_True ? 10 : ret == l_False ? 20 : 0);
+#endif
+    } catch (OutOfMemoryException&){
+        printf("===============================================================================\n");
+        printf("INDETERMINATE\n");
+        exit(0);
+    }
+}
diff -ruN src_tmp/minisat/simp/Makefile src/minisat/simp/Makefile
--- src_tmp/minisat/simp/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ src/minisat/simp/Makefile	2022-02-19 12:06:50.626500104 +0100
@@ -0,0 +1,4 @@
+EXEC      = minisat
+DEPDIR    = mtl utils core
+
+include $(MROOT)/mtl/template.mk
diff -ruN src_tmp/minisat/simp/SimpSolver.cc src/minisat/simp/SimpSolver.cc
--- src_tmp/minisat/simp/SimpSolver.cc	1970-01-01 01:00:00.000000000 +0100
+++ src/minisat/simp/SimpSolver.cc	2022-02-19 12:06:50.626500104 +0100
@@ -0,0 +1,717 @@
+/***********************************************************************************[SimpSolver.cc]
+Copyright (c) 2006,      Niklas Een, Niklas Sorensson
+Copyright (c) 2007-2010, Niklas Sorensson
+
+Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
+associated documentation files (the "Software"), to deal in the Software without restriction,
+including without limitation the rights to use, copy, modify, merge, publish, distribute,
+sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all copies or
+substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
+NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT
+OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+**************************************************************************************************/
+
+#include "mtl/Sort.h"
+#include "simp/SimpSolver.h"
+#include "utils/System.h"
+
+using namespace Minisat;
+
+//=================================================================================================
+// Options:
+
+
+static const char* _cat = "SIMP";
+
+static BoolOption   opt_use_asymm        (_cat, "asymm",        "Shrink clauses by asymmetric branching.", false);
+static BoolOption   opt_use_rcheck       (_cat, "rcheck",       "Check if a clause is already implied. (costly)", false);
+static BoolOption   opt_use_elim         (_cat, "elim",         "Perform variable elimination.", true);
+static IntOption    opt_grow             (_cat, "grow",         "Allow a variable elimination step to grow by a number of clauses.", 0);
+static IntOption    opt_clause_lim       (_cat, "cl-lim",       "Variables are not eliminated if it produces a resolvent with a length above this limit. -1 means no limit", 20,   IntRange(-1, INT32_MAX));
+static IntOption    opt_subsumption_lim  (_cat, "sub-lim",      "Do not check if subsumption against a clause larger than this. -1 means no limit.", 1000, IntRange(-1, INT32_MAX));
+static DoubleOption opt_simp_garbage_frac(_cat, "simp-gc-frac", "The fraction of wasted memory allowed before a garbage collection is triggered during simplification.",  0.5, DoubleRange(0, false, HUGE_VAL, false));
+
+
+//=================================================================================================
+// Constructor/Destructor:
+
+
+SimpSolver::SimpSolver() :
+    grow               (opt_grow)
+  , clause_lim         (opt_clause_lim)
+  , subsumption_lim    (opt_subsumption_lim)
+  , simp_garbage_frac  (opt_simp_garbage_frac)
+  , use_asymm          (opt_use_asymm)
+  , use_rcheck         (opt_use_rcheck)
+  , use_elim           (opt_use_elim)
+  , merges             (0)
+  , asymm_lits         (0)
+  , eliminated_vars    (0)
+  , elimorder          (1)
+  , use_simplification (true)
+  , occurs             (ClauseDeleted(ca))
+  , elim_heap          (ElimLt(n_occ))
+  , bwdsub_assigns     (0)
+  , n_touched          (0)
+{
+    vec<Lit> dummy(1,lit_Undef);
+    ca.extra_clause_field = true; // NOTE: must happen before allocating the dummy clause below.
+    bwdsub_tmpunit        = ca.alloc(dummy);
+    remove_satisfied      = false;
+}
+
+
+SimpSolver::~SimpSolver()
+{
+}
+
+
+Var SimpSolver::newVar(bool sign, bool dvar) {
+    Var v = Solver::newVar(sign, dvar);
+
+    frozen    .push((char)false);
+    eliminated.push((char)false);
+
+    if (use_simplification){
+        n_occ     .push(0);
+        n_occ     .push(0);
+        occurs    .init(v);
+        touched   .push(0);
+        elim_heap .insert(v);
+    }
+    return v; }
+
+
+
+lbool SimpSolver::solve_(bool do_simp, bool turn_off_simp)
+{
+    vec<Var> extra_frozen;
+    lbool    result = l_True;
+
+    do_simp &= use_simplification;
+
+    if (do_simp){
+        // Assumptions must be temporarily frozen to run variable elimination:
+        for (int i = 0; i < assumptions.size(); i++){
+            Var v = var(assumptions[i]);
+
+            // If an assumption has been eliminated, remember it.
+            assert(!isEliminated(v));
+
+            if (!frozen[v]){
+                // Freeze and store.
+                setFrozen(v, true);
+                extra_frozen.push(v);
+            } }
+
+        result = lbool(eliminate(turn_off_simp));
+    }
+
+    if (result == l_True)
+        result = Solver::solve_();
+    else if (verbosity >= 1)
+        printf("===============================================================================\n");
+
+    if (result == l_True)
+        extendModel();
+
+    if (do_simp)
+        // Unfreeze the assumptions that were frozen:
+        for (int i = 0; i < extra_frozen.size(); i++)
+            setFrozen(extra_frozen[i], false);
+
+    return result;
+}
+
+
+
+bool SimpSolver::addClause_(vec<Lit>& ps)
+{
+#ifndef NDEBUG
+    for (int i = 0; i < ps.size(); i++)
+        assert(!isEliminated(var(ps[i])));
+#endif
+
+    int nclauses = clauses.size();
+
+    if (use_rcheck && implied(ps))
+        return true;
+
+    if (!Solver::addClause_(ps))
+        return false;
+
+    if (use_simplification && clauses.size() == nclauses + 1){
+        CRef          cr = clauses.last();
+        const Clause& c  = ca[cr];
+
+        // NOTE: the clause is added to the queue immediately and then
+        // again during 'gatherTouchedClauses()'. If nothing happens
+        // in between, it will only be checked once. Otherwise, it may
+        // be checked twice unnecessarily. This is an unfortunate
+        // consequence of how backward subsumption is used to mimic
+        // forward subsumption.
+        subsumption_queue.insert(cr);
+        for (int i = 0; i < c.size(); i++){
+            occurs[var(c[i])].push(cr);
+            n_occ[toInt(c[i])]++;
+            touched[var(c[i])] = 1;
+            n_touched++;
+            if (elim_heap.inHeap(var(c[i])))
+                elim_heap.increase(var(c[i]));
+        }
+    }
+
+    return true;
+}
+
+
+void SimpSolver::removeClause(CRef cr)
+{
+    const Clause& c = ca[cr];
+
+    if (use_simplification)
+        for (int i = 0; i < c.size(); i++){
+            n_occ[toInt(c[i])]--;
+            updateElimHeap(var(c[i]));
+            occurs.smudge(var(c[i]));
+        }
+
+    Solver::removeClause(cr);
+}
+
+
+bool SimpSolver::strengthenClause(CRef cr, Lit l)
+{
+    Clause& c = ca[cr];
+    assert(decisionLevel() == 0);
+    assert(use_simplification);
+
+    // FIX: this is too inefficient but would be nice to have (properly implemented)
+    // if (!find(subsumption_queue, &c))
+    subsumption_queue.insert(cr);
+
+    if (c.size() == 2){
+        removeClause(cr);
+        c.strengthen(l);
+    }else{
+        detachClause(cr, true);
+        c.strengthen(l);
+        attachClause(cr);
+        remove(occurs[var(l)], cr);
+        n_occ[toInt(l)]--;
+        updateElimHeap(var(l));
+    }
+
+    return c.size() == 1 ? enqueue(c[0]) && propagate() == CRef_Undef : true;
+}
+
+
+// Returns FALSE if clause is always satisfied ('out_clause' should not be used).
+bool SimpSolver::merge(const Clause& _ps, const Clause& _qs, Var v, vec<Lit>& out_clause)
+{
+    merges++;
+    out_clause.clear();
+
+    bool  ps_smallest = _ps.size() < _qs.size();
+    const Clause& ps  =  ps_smallest ? _qs : _ps;
+    const Clause& qs  =  ps_smallest ? _ps : _qs;
+
+    for (int i = 0; i < qs.size(); i++){
+        if (var(qs[i]) != v){
+            for (int j = 0; j < ps.size(); j++)
+                if (var(ps[j]) == var(qs[i]))
+                    if (ps[j] == ~qs[i])
+                        return false;
+                    else
+                        goto next;
+            out_clause.push(qs[i]);
+        }
+        next:;
+    }
+
+    for (int i = 0; i < ps.size(); i++)
+        if (var(ps[i]) != v)
+            out_clause.push(ps[i]);
+
+    return true;
+}
+
+
+// Returns FALSE if clause is always satisfied.
+bool SimpSolver::merge(const Clause& _ps, const Clause& _qs, Var v, int& size)
+{
+    merges++;
+
+    bool  ps_smallest = _ps.size() < _qs.size();
+    const Clause& ps  =  ps_smallest ? _qs : _ps;
+    const Clause& qs  =  ps_smallest ? _ps : _qs;
+    const Lit*  __ps  = (const Lit*)ps;
+    const Lit*  __qs  = (const Lit*)qs;
+
+    size = ps.size()-1;
+
+    for (int i = 0; i < qs.size(); i++){
+        if (var(__qs[i]) != v){
+            for (int j = 0; j < ps.size(); j++)
+                if (var(__ps[j]) == var(__qs[i]))
+                    if (__ps[j] == ~__qs[i])
+                        return false;
+                    else
+                        goto next;
+            size++;
+        }
+        next:;
+    }
+
+    return true;
+}
+
+
+void SimpSolver::gatherTouchedClauses()
+{
+    if (n_touched == 0) return;
+
+    int i,j;
+    for (i = j = 0; i < subsumption_queue.size(); i++)
+        if (ca[subsumption_queue[i]].mark() == 0)
+            ca[subsumption_queue[i]].mark(2);
+
+    for (i = 0; i < touched.size(); i++)
+        if (touched[i]){
+            const vec<CRef>& cs = occurs.lookup(i);
+            for (j = 0; j < cs.size(); j++)
+                if (ca[cs[j]].mark() == 0){
+                    subsumption_queue.insert(cs[j]);
+                    ca[cs[j]].mark(2);
+                }
+            touched[i] = 0;
+        }
+
+    for (i = 0; i < subsumption_queue.size(); i++)
+        if (ca[subsumption_queue[i]].mark() == 2)
+            ca[subsumption_queue[i]].mark(0);
+
+    n_touched = 0;
+}
+
+
+bool SimpSolver::implied(const vec<Lit>& c)
+{
+    assert(decisionLevel() == 0);
+
+    trail_lim.push(trail.size());
+    for (int i = 0; i < c.size(); i++)
+        if (value(c[i]) == l_True){
+            cancelUntil(0);
+            return false;
+        }else if (value(c[i]) != l_False){
+            assert(value(c[i]) == l_Undef);
+            uncheckedEnqueue(~c[i]);
+        }
+
+    bool result = propagate() != CRef_Undef;
+    cancelUntil(0);
+    return result;
+}
+
+
+// Backward subsumption + backward subsumption resolution
+bool SimpSolver::backwardSubsumptionCheck(bool verbose)
+{
+    int cnt = 0;
+    int subsumed = 0;
+    int deleted_literals = 0;
+    assert(decisionLevel() == 0);
+
+    while (subsumption_queue.size() > 0 || bwdsub_assigns < trail.size()){
+
+        // Empty subsumption queue and return immediately on user-interrupt:
+        if (asynch_interrupt){
+            subsumption_queue.clear();
+            bwdsub_assigns = trail.size();
+            break; }
+
+        // Check top-level assignments by creating a dummy clause and placing it in the queue:
+        if (subsumption_queue.size() == 0 && bwdsub_assigns < trail.size()){
+            Lit l = trail[bwdsub_assigns++];
+            ca[bwdsub_tmpunit][0] = l;
+            ca[bwdsub_tmpunit].calcAbstraction();
+            subsumption_queue.insert(bwdsub_tmpunit); }
+
+        CRef    cr = subsumption_queue.peek(); subsumption_queue.pop();
+        Clause& c  = ca[cr];
+
+        if (c.mark()) continue;
+
+        if (verbose && verbosity >= 2 && cnt++ % 1000 == 0)
+            printf("subsumption left: %10d (%10d subsumed, %10d deleted literals)\r", subsumption_queue.size(), subsumed, deleted_literals);
+
+        assert(c.size() > 1 || value(c[0]) == l_True);    // Unit-clauses should have been propagated before this point.
+
+        // Find best variable to scan:
+        Var best = var(c[0]);
+        for (int i = 1; i < c.size(); i++)
+            if (occurs[var(c[i])].size() < occurs[best].size())
+                best = var(c[i]);
+
+        // Search all candidates:
+        vec<CRef>& _cs = occurs.lookup(best);
+        CRef*       cs = (CRef*)_cs;
+
+        for (int j = 0; j < _cs.size(); j++)
+            if (c.mark())
+                break;
+            else if (!ca[cs[j]].mark() &&  cs[j] != cr && (subsumption_lim == -1 || ca[cs[j]].size() < subsumption_lim)){
+                Lit l = c.subsumes(ca[cs[j]]);
+
+                if (l == lit_Undef)
+                    subsumed++, removeClause(cs[j]);
+                else if (l != lit_Error){
+                    deleted_literals++;
+
+                    if (!strengthenClause(cs[j], ~l))
+                        return false;
+
+                    // Did current candidate get deleted from cs? Then check candidate at index j again:
+                    if (var(l) == best)
+                        j--;
+                }
+            }
+    }
+
+    return true;
+}
+
+
+bool SimpSolver::asymm(Var v, CRef cr)
+{
+    Clause& c = ca[cr];
+    assert(decisionLevel() == 0);
+
+    if (c.mark() || satisfied(c)) return true;
+
+    trail_lim.push(trail.size());
+    Lit l = lit_Undef;
+    for (int i = 0; i < c.size(); i++)
+        if (var(c[i]) != v && value(c[i]) != l_False)
+            uncheckedEnqueue(~c[i]);
+        else
+            l = c[i];
+
+    if (propagate() != CRef_Undef){
+        cancelUntil(0);
+        asymm_lits++;
+        if (!strengthenClause(cr, l))
+            return false;
+    }else
+        cancelUntil(0);
+
+    return true;
+}
+
+
+bool SimpSolver::asymmVar(Var v)
+{
+    assert(use_simplification);
+
+    const vec<CRef>& cls = occurs.lookup(v);
+
+    if (value(v) != l_Undef || cls.size() == 0)
+        return true;
+
+    for (int i = 0; i < cls.size(); i++)
+        if (!asymm(v, cls[i]))
+            return false;
+
+    return backwardSubsumptionCheck();
+}
+
+
+static void mkElimClause(vec<uint32_t>& elimclauses, Lit x)
+{
+    elimclauses.push(toInt(x));
+    elimclauses.push(1);
+}
+
+
+static void mkElimClause(vec<uint32_t>& elimclauses, Var v, Clause& c)
+{
+    int first = elimclauses.size();
+    int v_pos = -1;
+
+    // Copy clause to elimclauses-vector. Remember position where the
+    // variable 'v' occurs:
+    for (int i = 0; i < c.size(); i++){
+        elimclauses.push(toInt(c[i]));
+        if (var(c[i]) == v)
+            v_pos = i + first;
+    }
+    assert(v_pos != -1);
+
+    // Swap the first literal with the 'v' literal, so that the literal
+    // containing 'v' will occur first in the clause:
+    uint32_t tmp = elimclauses[v_pos];
+    elimclauses[v_pos] = elimclauses[first];
+    elimclauses[first] = tmp;
+
+    // Store the length of the clause last:
+    elimclauses.push(c.size());
+}
+
+
+
+bool SimpSolver::eliminateVar(Var v)
+{
+    assert(!frozen[v]);
+    assert(!isEliminated(v));
+    assert(value(v) == l_Undef);
+
+    // Split the occurrences into positive and negative:
+    //
+    const vec<CRef>& cls = occurs.lookup(v);
+    vec<CRef>        pos, neg;
+    for (int i = 0; i < cls.size(); i++)
+        (find(ca[cls[i]], mkLit(v)) ? pos : neg).push(cls[i]);
+
+    // Check wether the increase in number of clauses stays within the allowed ('grow'). Moreover, no
+    // clause must exceed the limit on the maximal clause size (if it is set):
+    //
+    int cnt         = 0;
+    int clause_size = 0;
+
+    for (int i = 0; i < pos.size(); i++)
+        for (int j = 0; j < neg.size(); j++)
+            if (merge(ca[pos[i]], ca[neg[j]], v, clause_size) && 
+                (++cnt > cls.size() + grow || (clause_lim != -1 && clause_size > clause_lim)))
+                return true;
+
+    // Delete and store old clauses:
+    eliminated[v] = true;
+    setDecisionVar(v, false);
+    eliminated_vars++;
+
+    if (pos.size() > neg.size()){
+        for (int i = 0; i < neg.size(); i++)
+            mkElimClause(elimclauses, v, ca[neg[i]]);
+        mkElimClause(elimclauses, mkLit(v));
+    }else{
+        for (int i = 0; i < pos.size(); i++)
+            mkElimClause(elimclauses, v, ca[pos[i]]);
+        mkElimClause(elimclauses, ~mkLit(v));
+    }
+
+    for (int i = 0; i < cls.size(); i++)
+        removeClause(cls[i]); 
+
+    // Produce clauses in cross product:
+    vec<Lit>& resolvent = add_tmp;
+    for (int i = 0; i < pos.size(); i++)
+        for (int j = 0; j < neg.size(); j++)
+            if (merge(ca[pos[i]], ca[neg[j]], v, resolvent) && !addClause_(resolvent))
+                return false;
+
+    // Free occurs list for this variable:
+    occurs[v].clear(true);
+    
+    // Free watchers lists for this variable, if possible:
+    if (watches[ mkLit(v)].size() == 0) watches[ mkLit(v)].clear(true);
+    if (watches[~mkLit(v)].size() == 0) watches[~mkLit(v)].clear(true);
+
+    return backwardSubsumptionCheck();
+}
+
+
+bool SimpSolver::substitute(Var v, Lit x)
+{
+    assert(!frozen[v]);
+    assert(!isEliminated(v));
+    assert(value(v) == l_Undef);
+
+    if (!ok) return false;
+
+    eliminated[v] = true;
+    setDecisionVar(v, false);
+    const vec<CRef>& cls = occurs.lookup(v);
+    
+    vec<Lit>& subst_clause = add_tmp;
+    for (int i = 0; i < cls.size(); i++){
+        Clause& c = ca[cls[i]];
+
+        subst_clause.clear();
+        for (int j = 0; j < c.size(); j++){
+            Lit p = c[j];
+            subst_clause.push(var(p) == v ? x ^ sign(p) : p);
+        }
+
+        removeClause(cls[i]);
+
+        if (!addClause_(subst_clause))
+            return ok = false;
+    }
+
+    return true;
+}
+
+
+void SimpSolver::extendModel()
+{
+    int i, j;
+    Lit x;
+
+    for (i = elimclauses.size()-1; i > 0; i -= j){
+        for (j = elimclauses[i--]; j > 1; j--, i--)
+            if (modelValue(toLit(elimclauses[i])) != l_False)
+                goto next;
+
+        x = toLit(elimclauses[i]);
+        model[var(x)] = lbool(!sign(x));
+    next:;
+    }
+}
+
+
+bool SimpSolver::eliminate(bool turn_off_elim)
+{
+    if (!simplify())
+        return false;
+    else if (!use_simplification)
+        return true;
+
+    // Main simplification loop:
+    //
+    while (n_touched > 0 || bwdsub_assigns < trail.size() || elim_heap.size() > 0){
+
+        gatherTouchedClauses();
+        // printf("  ## (time = %6.2f s) BWD-SUB: queue = %d, trail = %d\n", cpuTime(), subsumption_queue.size(), trail.size() - bwdsub_assigns);
+        if ((subsumption_queue.size() > 0 || bwdsub_assigns < trail.size()) && 
+            !backwardSubsumptionCheck(true)){
+            ok = false; goto cleanup; }
+
+        // Empty elim_heap and return immediately on user-interrupt:
+        if (asynch_interrupt){
+            assert(bwdsub_assigns == trail.size());
+            assert(subsumption_queue.size() == 0);
+            assert(n_touched == 0);
+            elim_heap.clear();
+            goto cleanup; }
+
+        // printf("  ## (time = %6.2f s) ELIM: vars = %d\n", cpuTime(), elim_heap.size());
+        for (int cnt = 0; !elim_heap.empty(); cnt++){
+            Var elim = elim_heap.removeMin();
+            
+            if (asynch_interrupt) break;
+
+            if (isEliminated(elim) || value(elim) != l_Undef) continue;
+
+            if (verbosity >= 2 && cnt % 100 == 0)
+                printf("elimination left: %10d\r", elim_heap.size());
+
+            if (use_asymm){
+                // Temporarily freeze variable. Otherwise, it would immediately end up on the queue again:
+                bool was_frozen = frozen[elim];
+                frozen[elim] = true;
+                if (!asymmVar(elim)){
+                    ok = false; goto cleanup; }
+                frozen[elim] = was_frozen; }
+
+            // At this point, the variable may have been set by assymetric branching, so check it
+            // again. Also, don't eliminate frozen variables:
+            if (use_elim && value(elim) == l_Undef && !frozen[elim] && !eliminateVar(elim)){
+                ok = false; goto cleanup; }
+
+            checkGarbage(simp_garbage_frac);
+        }
+
+        assert(subsumption_queue.size() == 0);
+    }
+ cleanup:
+
+    // If no more simplification is needed, free all simplification-related data structures:
+    if (turn_off_elim){
+        touched  .clear(true);
+        occurs   .clear(true);
+        n_occ    .clear(true);
+        elim_heap.clear(true);
+        subsumption_queue.clear(true);
+
+        use_simplification    = false;
+        remove_satisfied      = true;
+        ca.extra_clause_field = false;
+
+        // Force full cleanup (this is safe and desirable since it only happens once):
+        rebuildOrderHeap();
+        garbageCollect();
+    }else{
+        // Cheaper cleanup:
+        cleanUpClauses(); // TODO: can we make 'cleanUpClauses()' not be linear in the problem size somehow?
+        checkGarbage();
+    }
+
+    if (verbosity >= 1 && elimclauses.size() > 0)
+        printf("|  Eliminated clauses:     %10.2f Mb                                      |\n", 
+               double(elimclauses.size() * sizeof(uint32_t)) / (1024*1024));
+
+    return ok;
+}
+
+
+void SimpSolver::cleanUpClauses()
+{
+    occurs.cleanAll();
+    int i,j;
+    for (i = j = 0; i < clauses.size(); i++)
+        if (ca[clauses[i]].mark() == 0)
+            clauses[j++] = clauses[i];
+    clauses.shrink(i - j);
+}
+
+
+//=================================================================================================
+// Garbage Collection methods:
+
+
+void SimpSolver::relocAll(ClauseAllocator& to)
+{
+    if (!use_simplification) return;
+
+    // All occurs lists:
+    //
+    for (int i = 0; i < nVars(); i++){
+        vec<CRef>& cs = occurs[i];
+        for (int j = 0; j < cs.size(); j++)
+            ca.reloc(cs[j], to);
+    }
+
+    // Subsumption queue:
+    //
+    for (int i = 0; i < subsumption_queue.size(); i++)
+        ca.reloc(subsumption_queue[i], to);
+
+    // Temporary clause:
+    //
+    ca.reloc(bwdsub_tmpunit, to);
+}
+
+
+void SimpSolver::garbageCollect()
+{
+    // Initialize the next region to a size corresponding to the estimated utilization degree. This
+    // is not precise but should avoid some unnecessary reallocations for the new region:
+    ClauseAllocator to(ca.size() - ca.wasted()); 
+
+    cleanUpClauses();
+    to.extra_clause_field = ca.extra_clause_field; // NOTE: this is important to keep (or lose) the extra fields.
+    relocAll(to);
+    Solver::relocAll(to);
+    if (verbosity >= 2)
+        printf("|  Garbage collection:   %12d bytes => %12d bytes             |\n", 
+               ca.size()*ClauseAllocator::Unit_Size, to.size()*ClauseAllocator::Unit_Size);
+    to.moveTo(ca);
+}
diff -ruN src_tmp/minisat/simp/SimpSolver.h src/minisat/simp/SimpSolver.h
--- src_tmp/minisat/simp/SimpSolver.h	1970-01-01 01:00:00.000000000 +0100
+++ src/minisat/simp/SimpSolver.h	2022-02-19 12:06:50.626500104 +0100
@@ -0,0 +1,197 @@
+/************************************************************************************[SimpSolver.h]
+Copyright (c) 2006,      Niklas Een, Niklas Sorensson
+Copyright (c) 2007-2010, Niklas Sorensson
+
+Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
+associated documentation files (the "Software"), to deal in the Software without restriction,
+including without limitation the rights to use, copy, modify, merge, publish, distribute,
+sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all copies or
+substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
+NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT
+OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+**************************************************************************************************/
+
+#ifndef Minisat_SimpSolver_h
+#define Minisat_SimpSolver_h
+
+#include "mtl/Queue.h"
+#include "core/Solver.h"
+
+
+namespace Minisat {
+
+//=================================================================================================
+
+
+class SimpSolver : public Solver {
+ public:
+    // Constructor/Destructor:
+    //
+    SimpSolver();
+    ~SimpSolver();
+
+    // Problem specification:
+    //
+    Var     newVar    (bool polarity = true, bool dvar = true);
+    bool    addClause (const vec<Lit>& ps);
+    bool    addEmptyClause();                // Add the empty clause to the solver.
+    bool    addClause (Lit p);               // Add a unit clause to the solver.
+    bool    addClause (Lit p, Lit q);        // Add a binary clause to the solver.
+    bool    addClause (Lit p, Lit q, Lit r); // Add a ternary clause to the solver.
+    bool    addClause_(      vec<Lit>& ps);
+    bool    substitute(Var v, Lit x);  // Replace all occurences of v with x (may cause a contradiction).
+
+    // Variable mode:
+    // 
+    void    setFrozen (Var v, bool b); // If a variable is frozen it will not be eliminated.
+    bool    isEliminated(Var v) const;
+
+    // Solving:
+    //
+    bool    solve       (const vec<Lit>& assumps, bool do_simp = true, bool turn_off_simp = false);
+    lbool   solveLimited(const vec<Lit>& assumps, bool do_simp = true, bool turn_off_simp = false);
+    bool    solve       (                     bool do_simp = true, bool turn_off_simp = false);
+    bool    solve       (Lit p       ,        bool do_simp = true, bool turn_off_simp = false);       
+    bool    solve       (Lit p, Lit q,        bool do_simp = true, bool turn_off_simp = false);
+    bool    solve       (Lit p, Lit q, Lit r, bool do_simp = true, bool turn_off_simp = false);
+    bool    eliminate   (bool turn_off_elim = false);  // Perform variable elimination based simplification. 
+
+    // Memory managment:
+    //
+    virtual void garbageCollect();
+
+
+    // Generate a (possibly simplified) DIMACS file:
+    //
+#if 0
+    void    toDimacs  (const char* file, const vec<Lit>& assumps);
+    void    toDimacs  (const char* file);
+    void    toDimacs  (const char* file, Lit p);
+    void    toDimacs  (const char* file, Lit p, Lit q);
+    void    toDimacs  (const char* file, Lit p, Lit q, Lit r);
+#endif
+
+    // Mode of operation:
+    //
+    int     grow;              // Allow a variable elimination step to grow by a number of clauses (default to zero).
+    int     clause_lim;        // Variables are not eliminated if it produces a resolvent with a length above this limit.
+                               // -1 means no limit.
+    int     subsumption_lim;   // Do not check if subsumption against a clause larger than this. -1 means no limit.
+    double  simp_garbage_frac; // A different limit for when to issue a GC during simplification (Also see 'garbage_frac').
+
+    bool    use_asymm;         // Shrink clauses by asymmetric branching.
+    bool    use_rcheck;        // Check if a clause is already implied. Prett costly, and subsumes subsumptions :)
+    bool    use_elim;          // Perform variable elimination.
+
+    // Statistics:
+    //
+    int     merges;
+    int     asymm_lits;
+    int     eliminated_vars;
+
+ protected:
+
+    // Helper structures:
+    //
+    struct ElimLt {
+        const vec<int>& n_occ;
+        explicit ElimLt(const vec<int>& no) : n_occ(no) {}
+
+        // TODO: are 64-bit operations here noticably bad on 32-bit platforms? Could use a saturating
+        // 32-bit implementation instead then, but this will have to do for now.
+        uint64_t cost  (Var x)        const { return (uint64_t)n_occ[toInt(mkLit(x))] * (uint64_t)n_occ[toInt(~mkLit(x))]; }
+        bool operator()(Var x, Var y) const { return cost(x) < cost(y); }
+        
+        // TODO: investigate this order alternative more.
+        // bool operator()(Var x, Var y) const { 
+        //     int c_x = cost(x);
+        //     int c_y = cost(y);
+        //     return c_x < c_y || c_x == c_y && x < y; }
+    };
+
+    struct ClauseDeleted {
+        const ClauseAllocator& ca;
+        explicit ClauseDeleted(const ClauseAllocator& _ca) : ca(_ca) {}
+        bool operator()(const CRef& cr) const { return ca[cr].mark() == 1; } };
+
+    // Solver state:
+    //
+    int                 elimorder;
+    bool                use_simplification;
+    vec<uint32_t>       elimclauses;
+    vec<char>           touched;
+    OccLists<Var, vec<CRef>, ClauseDeleted>
+                        occurs;
+    vec<int>            n_occ;
+    Heap<ElimLt>        elim_heap;
+    Queue<CRef>         subsumption_queue;
+    vec<char>           frozen;
+    vec<char>           eliminated;
+    int                 bwdsub_assigns;
+    int                 n_touched;
+
+    // Temporaries:
+    //
+    CRef                bwdsub_tmpunit;
+
+    // Main internal methods:
+    //
+    lbool         solve_                   (bool do_simp = true, bool turn_off_simp = false);
+    bool          asymm                    (Var v, CRef cr);
+    bool          asymmVar                 (Var v);
+    void          updateElimHeap           (Var v);
+    void          gatherTouchedClauses     ();
+    bool          merge                    (const Clause& _ps, const Clause& _qs, Var v, vec<Lit>& out_clause);
+    bool          merge                    (const Clause& _ps, const Clause& _qs, Var v, int& size);
+    bool          backwardSubsumptionCheck (bool verbose = false);
+    bool          eliminateVar             (Var v);
+    void          extendModel              ();
+
+    void          removeClause             (CRef cr);
+    bool          strengthenClause         (CRef cr, Lit l);
+    void          cleanUpClauses           ();
+    bool          implied                  (const vec<Lit>& c);
+    void          relocAll                 (ClauseAllocator& to);
+};
+
+
+//=================================================================================================
+// Implementation of inline methods:
+
+
+inline bool SimpSolver::isEliminated (Var v) const { return eliminated[v]; }
+inline void SimpSolver::updateElimHeap(Var v) {
+    assert(use_simplification);
+    // if (!frozen[v] && !isEliminated(v) && value(v) == l_Undef)
+    if (elim_heap.inHeap(v) || (!frozen[v] && !isEliminated(v) && value(v) == l_Undef))
+        elim_heap.update(v); }
+
+
+inline bool SimpSolver::addClause    (const vec<Lit>& ps)    { ps.copyTo(add_tmp); return addClause_(add_tmp); }
+inline bool SimpSolver::addEmptyClause()                     { add_tmp.clear(); return addClause_(add_tmp); }
+inline bool SimpSolver::addClause    (Lit p)                 { add_tmp.clear(); add_tmp.push(p); return addClause_(add_tmp); }
+inline bool SimpSolver::addClause    (Lit p, Lit q)          { add_tmp.clear(); add_tmp.push(p); add_tmp.push(q); return addClause_(add_tmp); }
+inline bool SimpSolver::addClause    (Lit p, Lit q, Lit r)   { add_tmp.clear(); add_tmp.push(p); add_tmp.push(q); add_tmp.push(r); return addClause_(add_tmp); }
+inline void SimpSolver::setFrozen    (Var v, bool b) { frozen[v] = (char)b; if (use_simplification && !b) { updateElimHeap(v); } }
+
+inline bool SimpSolver::solve        (                     bool do_simp, bool turn_off_simp)  { budgetOff(); assumptions.clear(); return solve_(do_simp, turn_off_simp) == l_True; }
+inline bool SimpSolver::solve        (Lit p       ,        bool do_simp, bool turn_off_simp)  { budgetOff(); assumptions.clear(); assumptions.push(p); return solve_(do_simp, turn_off_simp) == l_True; }
+inline bool SimpSolver::solve        (Lit p, Lit q,        bool do_simp, bool turn_off_simp)  { budgetOff(); assumptions.clear(); assumptions.push(p); assumptions.push(q); return solve_(do_simp, turn_off_simp) == l_True; }
+inline bool SimpSolver::solve        (Lit p, Lit q, Lit r, bool do_simp, bool turn_off_simp)  { budgetOff(); assumptions.clear(); assumptions.push(p); assumptions.push(q); assumptions.push(r); return solve_(do_simp, turn_off_simp) == l_True; }
+inline bool SimpSolver::solve        (const vec<Lit>& assumps, bool do_simp, bool turn_off_simp){ 
+    budgetOff(); assumps.copyTo(assumptions); return solve_(do_simp, turn_off_simp) == l_True; }
+
+inline lbool SimpSolver::solveLimited (const vec<Lit>& assumps, bool do_simp, bool turn_off_simp){ 
+    assumps.copyTo(assumptions); return solve_(do_simp, turn_off_simp); }
+
+//=================================================================================================
+}
+
+#endif
diff -ruN src_tmp/minisat/utils/Makefile src/minisat/utils/Makefile
--- src_tmp/minisat/utils/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ src/minisat/utils/Makefile	2022-02-19 12:06:50.626500104 +0100
@@ -0,0 +1,4 @@
+EXEC      = system_test
+DEPDIR    = mtl
+
+include $(MROOT)/mtl/template.mk
diff -ruN src_tmp/minisat/utils/Options.cc src/minisat/utils/Options.cc
--- src_tmp/minisat/utils/Options.cc	1970-01-01 01:00:00.000000000 +0100
+++ src/minisat/utils/Options.cc	2022-02-19 12:06:50.626500104 +0100
@@ -0,0 +1,91 @@
+/**************************************************************************************[Options.cc]
+Copyright (c) 2008-2010, Niklas Sorensson
+
+Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
+associated documentation files (the "Software"), to deal in the Software without restriction,
+including without limitation the rights to use, copy, modify, merge, publish, distribute,
+sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all copies or
+substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
+NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT
+OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+**************************************************************************************************/
+
+#include "mtl/Sort.h"
+#include "utils/Options.h"
+#include "utils/ParseUtils.h"
+
+using namespace Minisat;
+
+void Minisat::parseOptions(int& argc, char** argv, bool strict)
+{
+    int i, j;
+    for (i = j = 1; i < argc; i++){
+        const char* str = argv[i];
+        if (match(str, "--") && match(str, Option::getHelpPrefixString()) && match(str, "help")){
+            if (*str == '\0')
+                printUsageAndExit(argc, argv);
+            else if (match(str, "-verb"))
+                printUsageAndExit(argc, argv, true);
+        } else {
+            bool parsed_ok = false;
+        
+            for (int k = 0; !parsed_ok && k < Option::getOptionList().size(); k++){
+                parsed_ok = Option::getOptionList()[k]->parse(argv[i]);
+
+                // fprintf(stderr, "checking %d: %s against flag <%s> (%s)\n", i, argv[i], Option::getOptionList()[k]->name, parsed_ok ? "ok" : "skip");
+            }
+
+            if (!parsed_ok)
+                if (strict && match(argv[i], "-"))
+                    fprintf(stderr, "ERROR! Unknown flag \"%s\". Use '--%shelp' for help.\n", argv[i], Option::getHelpPrefixString()), exit(1);
+                else
+                    argv[j++] = argv[i];
+        }
+    }
+
+    argc -= (i - j);
+}
+
+
+void Minisat::setUsageHelp      (const char* str){ Option::getUsageString() = str; }
+void Minisat::setHelpPrefixStr  (const char* str){ Option::getHelpPrefixString() = str; }
+void Minisat::printUsageAndExit (int argc, char** argv, bool verbose)
+{
+    const char* usage = Option::getUsageString();
+    if (usage != NULL)
+        fprintf(stderr, usage, argv[0]);
+
+    sort(Option::getOptionList(), Option::OptionLt());
+
+    const char* prev_cat  = NULL;
+    const char* prev_type = NULL;
+
+    for (int i = 0; i < Option::getOptionList().size(); i++){
+        const char* cat  = Option::getOptionList()[i]->category;
+        const char* type = Option::getOptionList()[i]->type_name;
+
+        if (cat != prev_cat)
+            fprintf(stderr, "\n%s OPTIONS:\n\n", cat);
+        else if (type != prev_type)
+            fprintf(stderr, "\n");
+
+        Option::getOptionList()[i]->help(verbose);
+
+        prev_cat  = Option::getOptionList()[i]->category;
+        prev_type = Option::getOptionList()[i]->type_name;
+    }
+
+    fprintf(stderr, "\nHELP OPTIONS:\n\n");
+    fprintf(stderr, "  --%shelp        Print help message.\n", Option::getHelpPrefixString());
+    fprintf(stderr, "  --%shelp-verb   Print verbose help message.\n", Option::getHelpPrefixString());
+    fprintf(stderr, "\n");
+    exit(0);
+}
+
diff -ruN src_tmp/minisat/utils/Options.h src/minisat/utils/Options.h
--- src_tmp/minisat/utils/Options.h	1970-01-01 01:00:00.000000000 +0100
+++ src/minisat/utils/Options.h	2022-02-19 12:06:50.626500104 +0100
@@ -0,0 +1,386 @@
+/***************************************************************************************[Options.h]
+Copyright (c) 2008-2010, Niklas Sorensson
+
+Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
+associated documentation files (the "Software"), to deal in the Software without restriction,
+including without limitation the rights to use, copy, modify, merge, publish, distribute,
+sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all copies or
+substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
+NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT
+OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+**************************************************************************************************/
+
+#ifndef Minisat_Options_h
+#define Minisat_Options_h
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <math.h>
+#include <string.h>
+
+#include "mtl/IntTypes.h"
+#include "mtl/Vec.h"
+#include "utils/ParseUtils.h"
+
+namespace Minisat {
+
+//==================================================================================================
+// Top-level option parse/help functions:
+
+
+extern void parseOptions     (int& argc, char** argv, bool strict = false);
+extern void printUsageAndExit(int  argc, char** argv, bool verbose = false);
+extern void setUsageHelp     (const char* str);
+extern void setHelpPrefixStr (const char* str);
+
+
+//==================================================================================================
+// Options is an abstract class that gives the interface for all types options:
+
+
+class Option
+{
+ protected:
+    const char* name;
+    const char* description;
+    const char* category;
+    const char* type_name;
+
+    static vec<Option*>& getOptionList () { static vec<Option*> options; return options; }
+    static const char*&  getUsageString() { static const char* usage_str; return usage_str; }
+    static const char*&  getHelpPrefixString() { static const char* help_prefix_str = ""; return help_prefix_str; }
+
+    struct OptionLt {
+        bool operator()(const Option* x, const Option* y) {
+            int test1 = strcmp(x->category, y->category);
+            return test1 < 0 || test1 == 0 && strcmp(x->type_name, y->type_name) < 0;
+        }
+    };
+
+    Option(const char* name_, 
+           const char* desc_,
+           const char* cate_,
+           const char* type_) : 
+      name       (name_)
+    , description(desc_)
+    , category   (cate_)
+    , type_name  (type_)
+    { 
+        getOptionList().push(this); 
+    }
+
+ public:
+    virtual ~Option() {}
+
+    virtual bool parse             (const char* str)      = 0;
+    virtual void help              (bool verbose = false) = 0;
+
+    friend  void parseOptions      (int& argc, char** argv, bool strict);
+    friend  void printUsageAndExit (int  argc, char** argv, bool verbose);
+    friend  void setUsageHelp      (const char* str);
+    friend  void setHelpPrefixStr  (const char* str);
+};
+
+
+//==================================================================================================
+// Range classes with specialization for floating types:
+
+
+struct IntRange {
+    int begin;
+    int end;
+    IntRange(int b, int e) : begin(b), end(e) {}
+};
+
+struct Int64Range {
+    int64_t begin;
+    int64_t end;
+    Int64Range(int64_t b, int64_t e) : begin(b), end(e) {}
+};
+
+struct DoubleRange {
+    double begin;
+    double end;
+    bool  begin_inclusive;
+    bool  end_inclusive;
+    DoubleRange(double b, bool binc, double e, bool einc) : begin(b), end(e), begin_inclusive(binc), end_inclusive(einc) {}
+};
+
+
+//==================================================================================================
+// Double options:
+
+
+class DoubleOption : public Option
+{
+ protected:
+    DoubleRange range;
+    double      value;
+
+ public:
+    DoubleOption(const char* c, const char* n, const char* d, double def = double(), DoubleRange r = DoubleRange(-HUGE_VAL, false, HUGE_VAL, false))
+        : Option(n, d, c, "<double>"), range(r), value(def) {
+        // FIXME: set LC_NUMERIC to "C" to make sure that strtof/strtod parses decimal point correctly.
+    }
+
+    operator      double   (void) const { return value; }
+    operator      double&  (void)       { return value; }
+    DoubleOption& operator=(double x)   { value = x; return *this; }
+
+    virtual bool parse(const char* str){
+        const char* span = str; 
+
+        if (!match(span, "-") || !match(span, name) || !match(span, "="))
+            return false;
+
+        char*  end;
+        double tmp = strtod(span, &end);
+
+        if (end == NULL) 
+            return false;
+        else if (tmp >= range.end && (!range.end_inclusive || tmp != range.end)){
+            fprintf(stderr, "ERROR! value <%s> is too large for option \"%s\".\n", span, name);
+            exit(1);
+        }else if (tmp <= range.begin && (!range.begin_inclusive || tmp != range.begin)){
+            fprintf(stderr, "ERROR! value <%s> is too small for option \"%s\".\n", span, name);
+            exit(1); }
+
+        value = tmp;
+        // fprintf(stderr, "READ VALUE: %g\n", value);
+
+        return true;
+    }
+
+    virtual void help (bool verbose = false){
+        fprintf(stderr, "  -%-12s = %-8s %c%4.2g .. %4.2g%c (default: %g)\n", 
+                name, type_name, 
+                range.begin_inclusive ? '[' : '(', 
+                range.begin,
+                range.end,
+                range.end_inclusive ? ']' : ')', 
+                value);
+        if (verbose){
+            fprintf(stderr, "\n        %s\n", description);
+            fprintf(stderr, "\n");
+        }
+    }
+};
+
+
+//==================================================================================================
+// Int options:
+
+
+class IntOption : public Option
+{
+ protected:
+    IntRange range;
+    int32_t  value;
+
+ public:
+    IntOption(const char* c, const char* n, const char* d, int32_t def = int32_t(), IntRange r = IntRange(INT32_MIN, INT32_MAX))
+        : Option(n, d, c, "<int32>"), range(r), value(def) {}
+ 
+    operator   int32_t   (void) const { return value; }
+    operator   int32_t&  (void)       { return value; }
+    IntOption& operator= (int32_t x)  { value = x; return *this; }
+
+    virtual bool parse(const char* str){
+        const char* span = str; 
+
+        if (!match(span, "-") || !match(span, name) || !match(span, "="))
+            return false;
+
+        char*   end;
+        int32_t tmp = strtol(span, &end, 10);
+
+        if (end == NULL) 
+            return false;
+        else if (tmp > range.end){
+            fprintf(stderr, "ERROR! value <%s> is too large for option \"%s\".\n", span, name);
+            exit(1);
+        }else if (tmp < range.begin){
+            fprintf(stderr, "ERROR! value <%s> is too small for option \"%s\".\n", span, name);
+            exit(1); }
+
+        value = tmp;
+
+        return true;
+    }
+
+    virtual void help (bool verbose = false){
+        fprintf(stderr, "  -%-12s = %-8s [", name, type_name);
+        if (range.begin == INT32_MIN)
+            fprintf(stderr, "imin");
+        else
+            fprintf(stderr, "%4d", range.begin);
+
+        fprintf(stderr, " .. ");
+        if (range.end == INT32_MAX)
+            fprintf(stderr, "imax");
+        else
+            fprintf(stderr, "%4d", range.end);
+
+        fprintf(stderr, "] (default: %d)\n", value);
+        if (verbose){
+            fprintf(stderr, "\n        %s\n", description);
+            fprintf(stderr, "\n");
+        }
+    }
+};
+
+
+// Leave this out for visual C++ until Microsoft implements C99 and gets support for strtoll.
+#ifndef _MSC_VER
+
+class Int64Option : public Option
+{
+ protected:
+    Int64Range range;
+    int64_t  value;
+
+ public:
+    Int64Option(const char* c, const char* n, const char* d, int64_t def = int64_t(), Int64Range r = Int64Range(INT64_MIN, INT64_MAX))
+        : Option(n, d, c, "<int64>"), range(r), value(def) {}
+ 
+    operator     int64_t   (void) const { return value; }
+    operator     int64_t&  (void)       { return value; }
+    Int64Option& operator= (int64_t x)  { value = x; return *this; }
+
+    virtual bool parse(const char* str){
+        const char* span = str; 
+
+        if (!match(span, "-") || !match(span, name) || !match(span, "="))
+            return false;
+
+        char*   end;
+        int64_t tmp = strtoll(span, &end, 10);
+
+        if (end == NULL) 
+            return false;
+        else if (tmp > range.end){
+            fprintf(stderr, "ERROR! value <%s> is too large for option \"%s\".\n", span, name);
+            exit(1);
+        }else if (tmp < range.begin){
+            fprintf(stderr, "ERROR! value <%s> is too small for option \"%s\".\n", span, name);
+            exit(1); }
+
+        value = tmp;
+
+        return true;
+    }
+
+    virtual void help (bool verbose = false){
+        fprintf(stderr, "  -%-12s = %-8s [", name, type_name);
+        if (range.begin == INT64_MIN)
+            fprintf(stderr, "imin");
+        else
+            fprintf(stderr, "%4"PRIi64, range.begin);
+
+        fprintf(stderr, " .. ");
+        if (range.end == INT64_MAX)
+            fprintf(stderr, "imax");
+        else
+            fprintf(stderr, "%4"PRIi64, range.end);
+
+        fprintf(stderr, "] (default: %"PRIi64")\n", value);
+        if (verbose){
+            fprintf(stderr, "\n        %s\n", description);
+            fprintf(stderr, "\n");
+        }
+    }
+};
+#endif
+
+//==================================================================================================
+// String option:
+
+
+class StringOption : public Option
+{
+    const char* value;
+ public:
+    StringOption(const char* c, const char* n, const char* d, const char* def = NULL) 
+        : Option(n, d, c, "<string>"), value(def) {}
+
+    operator      const char*  (void) const     { return value; }
+    operator      const char*& (void)           { return value; }
+    StringOption& operator=    (const char* x)  { value = x; return *this; }
+
+    virtual bool parse(const char* str){
+        const char* span = str; 
+
+        if (!match(span, "-") || !match(span, name) || !match(span, "="))
+            return false;
+
+        value = span;
+        return true;
+    }
+
+    virtual void help (bool verbose = false){
+        fprintf(stderr, "  -%-10s = %8s\n", name, type_name);
+        if (verbose){
+            fprintf(stderr, "\n        %s\n", description);
+            fprintf(stderr, "\n");
+        }
+    }    
+};
+
+
+//==================================================================================================
+// Bool option:
+
+
+class BoolOption : public Option
+{
+    bool value;
+
+ public:
+    BoolOption(const char* c, const char* n, const char* d, bool v) 
+        : Option(n, d, c, "<bool>"), value(v) {}
+
+    operator    bool     (void) const { return value; }
+    operator    bool&    (void)       { return value; }
+    BoolOption& operator=(bool b)     { value = b; return *this; }
+
+    virtual bool parse(const char* str){
+        const char* span = str; 
+        
+        if (match(span, "-")){
+            bool b = !match(span, "no-");
+
+            if (strcmp(span, name) == 0){
+                value = b;
+                return true; }
+        }
+
+        return false;
+    }
+
+    virtual void help (bool verbose = false){
+
+        fprintf(stderr, "  -%s, -no-%s", name, name);
+
+        for (uint32_t i = 0; i < 32 - strlen(name)*2; i++)
+            fprintf(stderr, " ");
+
+        fprintf(stderr, " ");
+        fprintf(stderr, "(default: %s)\n", value ? "on" : "off");
+        if (verbose){
+            fprintf(stderr, "\n        %s\n", description);
+            fprintf(stderr, "\n");
+        }
+    }
+};
+
+//=================================================================================================
+}
+
+#endif
diff -ruN src_tmp/minisat/utils/ParseUtils.h src/minisat/utils/ParseUtils.h
--- src_tmp/minisat/utils/ParseUtils.h	1970-01-01 01:00:00.000000000 +0100
+++ src/minisat/utils/ParseUtils.h	2022-02-19 12:06:50.626500104 +0100
@@ -0,0 +1,122 @@
+/************************************************************************************[ParseUtils.h]
+Copyright (c) 2003-2006, Niklas Een, Niklas Sorensson
+Copyright (c) 2007-2010, Niklas Sorensson
+
+Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
+associated documentation files (the "Software"), to deal in the Software without restriction,
+including without limitation the rights to use, copy, modify, merge, publish, distribute,
+sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all copies or
+substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
+NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT
+OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+**************************************************************************************************/
+
+#ifndef Minisat_ParseUtils_h
+#define Minisat_ParseUtils_h
+
+#include <stdlib.h>
+#include <stdio.h>
+
+#include <zlib.h>
+
+namespace Minisat {
+
+//-------------------------------------------------------------------------------------------------
+// A simple buffered character stream class:
+
+static const int buffer_size = 1048576;
+
+
+class StreamBuffer {
+    gzFile        in;
+    unsigned char buf[buffer_size];
+    int           pos;
+    int           size;
+
+    void assureLookahead() {
+        if (pos >= size) {
+            pos  = 0;
+            size = gzread(in, buf, sizeof(buf)); } }
+
+public:
+    explicit StreamBuffer(gzFile i) : in(i), pos(0), size(0) { assureLookahead(); }
+
+    int  operator *  () const { return (pos >= size) ? EOF : buf[pos]; }
+    void operator ++ ()       { pos++; assureLookahead(); }
+    int  position    () const { return pos; }
+};
+
+
+//-------------------------------------------------------------------------------------------------
+// End-of-file detection functions for StreamBuffer and char*:
+
+
+static inline bool isEof(StreamBuffer& in) { return *in == EOF;  }
+static inline bool isEof(const char*   in) { return *in == '\0'; }
+
+//-------------------------------------------------------------------------------------------------
+// Generic parse functions parametrized over the input-stream type.
+
+
+template<class B>
+static void skipWhitespace(B& in) {
+    while ((*in >= 9 && *in <= 13) || *in == 32)
+        ++in; }
+
+
+template<class B>
+static void skipLine(B& in) {
+    for (;;){
+        if (isEof(in)) return;
+        if (*in == '\n') { ++in; return; }
+        ++in; } }
+
+
+template<class B>
+static int parseInt(B& in) {
+    int     val = 0;
+    bool    neg = false;
+    skipWhitespace(in);
+    if      (*in == '-') neg = true, ++in;
+    else if (*in == '+') ++in;
+    if (*in < '0' || *in > '9') fprintf(stderr, "PARSE ERROR! Unexpected char: %c\n", *in), exit(3);
+    while (*in >= '0' && *in <= '9')
+        val = val*10 + (*in - '0'),
+        ++in;
+    return neg ? -val : val; }
+
+
+// String matching: in case of a match the input iterator will be advanced the corresponding
+// number of characters.
+template<class B>
+static bool match(B& in, const char* str) {
+    int i;
+    for (i = 0; str[i] != '\0'; i++)
+        if (in[i] != str[i])
+            return false;
+
+    in += i;
+
+    return true; 
+}
+
+// String matching: consumes characters eagerly, but does not require random access iterator.
+template<class B>
+static bool eagerMatch(B& in, const char* str) {
+    for (; *str != '\0'; ++str, ++in)
+        if (*str != *in)
+            return false;
+    return true; }
+
+
+//=================================================================================================
+}
+
+#endif
diff -ruN src_tmp/minisat/utils/System.cc src/minisat/utils/System.cc
--- src_tmp/minisat/utils/System.cc	1970-01-01 01:00:00.000000000 +0100
+++ src/minisat/utils/System.cc	2022-02-19 12:06:50.626500104 +0100
@@ -0,0 +1,95 @@
+/***************************************************************************************[System.cc]
+Copyright (c) 2003-2006, Niklas Een, Niklas Sorensson
+Copyright (c) 2007-2010, Niklas Sorensson
+
+Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
+associated documentation files (the "Software"), to deal in the Software without restriction,
+including without limitation the rights to use, copy, modify, merge, publish, distribute,
+sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all copies or
+substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
+NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT
+OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+**************************************************************************************************/
+
+#include "utils/System.h"
+
+#if defined(__linux__)
+
+#include <stdio.h>
+#include <stdlib.h>
+
+using namespace Minisat;
+
+// TODO: split the memory reading functions into two: one for reading high-watermark of RSS, and
+// one for reading the current virtual memory size.
+
+static inline int memReadStat(int field)
+{
+    char  name[256];
+    pid_t pid = getpid();
+    int   value;
+
+    sprintf(name, "/proc/%d/statm", pid);
+    FILE* in = fopen(name, "rb");
+    if (in == NULL) return 0;
+
+    for (; field >= 0; field--)
+        if (fscanf(in, "%d", &value) != 1)
+            printf("ERROR! Failed to parse memory statistics from \"/proc\".\n"), exit(1);
+    fclose(in);
+    return value;
+}
+
+
+static inline int memReadPeak(void)
+{
+    char  name[256];
+    pid_t pid = getpid();
+
+    sprintf(name, "/proc/%d/status", pid);
+    FILE* in = fopen(name, "rb");
+    if (in == NULL) return 0;
+
+    // Find the correct line, beginning with "VmPeak:":
+    int peak_kb = 0;
+    while (!feof(in) && fscanf(in, "VmPeak: %d kB", &peak_kb) != 1)
+        while (!feof(in) && fgetc(in) != '\n')
+            ;
+    fclose(in);
+
+    return peak_kb;
+}
+
+double Minisat::memUsed() { return (double)memReadStat(0) * (double)getpagesize() / (1024*1024); }
+double Minisat::memUsedPeak() { 
+    double peak = memReadPeak() / 1024;
+    return peak == 0 ? memUsed() : peak; }
+
+#elif defined(__FreeBSD__)
+
+double Minisat::memUsed(void) {
+    struct rusage ru;
+    getrusage(RUSAGE_SELF, &ru);
+    return (double)ru.ru_maxrss / 1024; }
+double MiniSat::memUsedPeak(void) { return memUsed(); }
+
+
+#elif defined(__APPLE__)
+#include <malloc/malloc.h>
+
+double Minisat::memUsed(void) {
+    malloc_statistics_t t;
+    malloc_zone_statistics(NULL, &t);
+    return (double)t.max_size_in_use / (1024*1024); }
+
+#else
+double Minisat::memUsed() { 
+    return 0; }
+#endif
diff -ruN src_tmp/minisat/utils/System.h src/minisat/utils/System.h
--- src_tmp/minisat/utils/System.h	1970-01-01 01:00:00.000000000 +0100
+++ src/minisat/utils/System.h	2022-02-19 12:06:50.626500104 +0100
@@ -0,0 +1,60 @@
+/****************************************************************************************[System.h]
+Copyright (c) 2003-2006, Niklas Een, Niklas Sorensson
+Copyright (c) 2007-2010, Niklas Sorensson
+
+Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
+associated documentation files (the "Software"), to deal in the Software without restriction,
+including without limitation the rights to use, copy, modify, merge, publish, distribute,
+sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all copies or
+substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
+NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT
+OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+**************************************************************************************************/
+
+#ifndef Minisat_System_h
+#define Minisat_System_h
+
+#if defined(__linux__)
+#include <fpu_control.h>
+#endif
+
+#include "mtl/IntTypes.h"
+
+//-------------------------------------------------------------------------------------------------
+
+namespace Minisat {
+
+static inline double cpuTime(void); // CPU-time in seconds.
+extern double memUsed();            // Memory in mega bytes (returns 0 for unsupported architectures).
+extern double memUsedPeak();        // Peak-memory in mega bytes (returns 0 for unsupported architectures).
+
+}
+
+//-------------------------------------------------------------------------------------------------
+// Implementation of inline functions:
+
+#if defined(_MSC_VER) || defined(__MINGW32__)
+#include <time.h>
+
+static inline double Minisat::cpuTime(void) { return (double)clock() / CLOCKS_PER_SEC; }
+
+#else
+#include <sys/time.h>
+#include <sys/resource.h>
+#include <unistd.h>
+
+static inline double Minisat::cpuTime(void) {
+    struct rusage ru;
+    getrusage(RUSAGE_SELF, &ru);
+    return (double)ru.ru_utime.tv_sec + (double)ru.ru_utime.tv_usec / 1000000; }
+
+#endif
+
+#endif
